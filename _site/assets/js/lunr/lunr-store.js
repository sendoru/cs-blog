var store = [{
        "title": "Writing The First Post",
        "excerpt":"              Hello, world!는 언제나 국룰이다.   // cpp #include &lt;iostream&gt; int main() {     std::cout &lt;&lt; \"Hello, world!\" &lt;&lt; std::endl;     return 0; }   # python print(\"Hello, world!\")   // Rust use std::io; fn main() {     println!(\"Hello, world!\"); }   console.log(\"Hello, world!\")   To-Do List         ✅ 블로그에 글 하나 올리기       ✅ 블로그 메인 화면 및 사이드바 등에 개인정보 채워두기 (닉네임, 깃헙 링크 등등)       ⬜ 제대로 된 자기소개 페이지 하나 만들기 &lt;- 쓸 거 없어서 못 만드는 중 ㄱ      ✅ 블로그 맨 위에 메뉴 바 만들기       ✅ 블로그 포스트 검색 기능 만들기       ✅ 폰트 및 레이아웃 조절하기. 아직 할 게 좀 남았는데 글 하나 더 써서 기록해둬야겠다.      ✅ 태그 및 기능 추가하기       ❔ 블로그 포스트 연도별 / 카테고리 별 뷰 만들기 &lt;- 반 정도 함       ⬜ 블로그에 HTML로 포스트 올리기 생각보다 구리다. 그냥 MD에 임베드해서 쓰자.       ⬜ Javascript 관련 기능 어떻게 쓰는지 알아보기 나중에 할래   Tips &amp; Troubleshooting           Mardown 파일에 포스트 제목을 따로 쓸 필요는 없다. 굳이 쓰면 이렇게 제목이 두 번 표시된다.                    이미지에 테두리 넣는 법도 배웠다?              Markdown 스타일 List       Markdown에서 1. ... &lt;br&gt; 2. ... &lt;br&gt; ...같은 형태로 글을 쓰면 저절로 ordered list가 된다. ordered list 안의 (plain text를 포함한) 컴포넌트를 작성할 때 들여쓰기를 안 해주면 컴포넌트가 리스트 밖으로 빠져나온다던가 리스트 번호가 1부터 다시 시작한다던가 하는 안 좋은 일이 일어난다. HTML의 &lt;ol&gt; + &lt;li&gt; 등의 태그에서는 스코프가 명확히 정해져 있어서 이런 걸 쓰면 크게 신경 쓸 필요는 없는 일이긴 하다.                     대충 이렇게 된다.              LaTeX 수식       LaTeX로 수식을 써보자.   \\[e^{i \\theta} = \\cos \\theta + i \\sin \\theta\\]      그냥은 안 된다. 다음 코드를 HTML의 &lt;head&gt;에 추가하면 된다.       &lt;head&gt;      &lt;script type=\"text/x-mathjax-config\"&gt;       MathJax.Hub.Config({       tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}       });       &lt;/script&gt;       &lt;script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async&gt;&lt;/script&gt;  &lt;/head&gt;          Markdown으로 작성 중인 경우에는 &lt;head&gt; &lt;/head&gt; 문서 맨 위에 새로 만들어주고 그 안에 저걸 끼워넣으면 된다. 그런데 markdown에서 이렇게 하면 VSCode의 Markdown Preview 확장 프로그램이 맛이 가기 때문에 작성 내용이 어떻게 표시되는지 보고 싶다면 웹 브라우저에서 확인해야 한다.            레이아웃 변경       지금 레이아웃에서 마음에 안 드는 게 몇 가지 있다.                    일반적인 PC 환경인 가로로 길쭉한 화면 상태에서, 글씨가 쓸데없이 커져서 한 화면에 표시되는 정보량이 너무 적어진다. 화면의 가로 길이가 너무 짧다는 생각도 드는데 이것도 폰트 영향일 수도 있어서 폰트부터 고쳐 본 다음에 다시 확인해야 될 것 같다.                   이 정도면 좋을텐데         반응형 UI의 폰트 크기 조절은 _sass/minimal-mistakes/_reset.scss에서 맨 위에 보이는 html 블럭 내의 값들을 바꿔 주면 된다. 가로 폭 조절은 _sass/minimal-mistakes/_variables.scss에서 breakpoints주석 아래에 있는 걸 고쳐주면 된다.            태그 및 카테고리 지정       Markdown 파일 맨 앞에 이렇게 생긴 걸 추가하면 된다.       ---  title: \"Writing The First Post\"  categories:      - Others  tags:      - html      - css      - markup  ---           카테고리를 추가하거나 변경하면 포스트 주소가 바뀐다. 카테고리를 지정하지 않았을 때 주소가 http://sendoru.github.io/cs-blog/writing-the-first-post/였다면, 카테고리를 Others로 바꾼 후에는 http://sendoru.github.io/cs-blog/others/writing-the-first-post/가 된다.       위 문단에서 첫 번째 링크는 접속이 안 되어야 할 것 같은데 캐싱된 게 있는지 예전 페이지로 접속이 된다. 별 상관은 없을 듯            &lt;div&gt; 또는 그 이외의 컨테이너 가운데 정렬        &lt;figure&gt;      &lt;img src=\"/cs-blog/assets/images/writing-the-first-post/image_4.png\" alt=\"\"&gt;      &lt;figcaption&gt; 이 정도면 좋을텐데 &lt;/figcaption&gt;  &lt;/figure&gt;           이렇게 이미지를 넣을 때, 이미지 사이즈를 80%로 줄이고 가운데 정렬로 만드려면  style=\"width: 80%; margin: auto;\" 스타일 속성을 figure에 넣어줘야 한다.       ","categories": ["Others"],
        "tags": ["html","css","markup"],
        "url": "/cs-blog/others/writing-the-first-post/",
        "teaser": null
      },{
        "title": "Writing HTML Post",
        "excerpt":"        Hello, world!                     ","categories": ["Others"],
        "tags": ["html","css"],
        "url": "/cs-blog/others/writing-html-post/",
        "teaser": null
      },{
        "title": "레이아웃 수정 To-Do List",
        "excerpt":"  문제 해결           포스트 페이지 하단의 YOU MAY ALSO ENJOY                     브라우저의 width가 medium일 때 문제가 발생한다.       대충 고쳤다. _sass/minimal-mistakes/_page.scss에서, .page__related에 아래 있는 저걸 추가하면 된다.        @include breakpoint($medium) {      width: 100%;  }                상단바 메뉴                     엄밀히 말하면 문제는 아닌 것 같지만, 메뉴 전체를 보여줄 수 없을 정도로 브라우저 width가 작다면 그냥 오른쪽 위 더보기 메뉴에 모든 메뉴를 몰아넣을 수 있으면 좋을 것 같다. 솔직히 몬가 좀 불편하다.       기능 추가   포스트 기본 스플래시 이미지 / 미리보기 사진 추가   블로그 배너 추가   포스트 목차 추가  ","categories": ["Others"],
        "tags": ["html","css"],
        "url": "/cs-blog/others/%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83-%EC%88%98%EC%A0%95-to-do-list/",
        "teaser": null
      },{
        "title": "Ubuntu Destop + Nvidia Gpu 환경에서 듀얼 모니터 설정",
        "excerpt":"  나는 좀 특이한 구성으로 듀얼 모니터 환경을 세팅해 놨다. 왼쪽에는 1920*1080 해상도의 서브 모니터를 90도 회전시킨 다음 화면 맨 위쪽까지 쳐다보는 게 불편해서 위아래 일부를 잘라놓은 상태로 1080*1440 해상도로 사용하고 있고, 오른쪽에는 2560*1440 해상도의 메인 모니터를 그나마 평범하게 설치해서 사용하고 있다.   NVIDIA X Server를 잘 만져줘서 설정이 제대로 됐다고 생각하고 대충 잘 쓰고 있다가 재부팅을 해 보니 문제가 발생했다. 로그온 화면에서 메인 모니터가 왼쪽 모니터로 설정이 돼 있는지 왼쪽 모니터에 반대 방향으로 90도 돌아간 로그인화면이 떠 있고, 로그인을 하고 나니 메인 모니터는 제대로 잡혔지만 서브 모니터가 1080*1920 사이즈로 화면을 꽉 채우고 있었다.   나중에 Ubuntu를 재설치하거나 다른 PC에 깔 때 삽질하지 않기 위해서 일단 써 둔다.   일단 GPU 드라이버는 설치됐다고 가정하고 글을 쓰겠다. 설치가 안 되어 있다면 이런 글을 참고해서 설치해 주도록 하자.           NVIDIA X Server로 설정 변경       우선 터미널에 sudo nvidia-settings를 쳐서 X Server를 실행시킨다. 듀얼 모니터의 해상도나 모니터 배치 같은 설정은 왼쪽 메뉴에서 X Server Display Configuration을 선택하면 볼 수 있다.       메인 모니터 설정은, 위쪽에서 메인 모니터로 설정할 모니터를 선택하고 Make this the primary display for the X screen을 체크해주면 된다. 모니터를 회전시켜서 사용하는 경우, Orientation의 설정을 바꿔주면 된다.       나처럼 모니터의 일부만 사용할 경우 Advanced… 뷰의 ViewPortIn, ViewPortOut, Panning 옵션을 사용해야 된다.                     ViewPortIn과 Panning에는 모두 출력할 화면의 해상도를 적는다. ViewPortOut은 XsizexYsize+Xoffset+Yoffset 형식이다. 모니터를 회전시키지 않은 상태라면 XsizexYsize 부분에는 ViewPortIn과 Panning에 적은 값을 그대로 적으면 되고, 회전시켰다면 Xsize와 Ysize의 순서를 바꿔서 적으면 된다. Xoffset과 Yoffset은 화면의 표시 위치를 결정하는 변수이다. 잘 조절해 가면서 자신에게 맞는 값을 설정하면 된다.            재부팅 / 다시 로그인 했을 때도 설정 유지       터미널에 sudo nvidia-settings를 쳐서 xorg.conf 파일을 생성한다. 이후 xorg.conf 파일에서 “Device”로 시작하는 블럭을 찾은 후, 아래 내용을 블럭 끝에 붙여넣는다.        Option \"RegistryDwords\" \"PowerMizerEnable=0x1; PerfLevelSrc=0x3322\"           (출처: https://askubuntu.com/questions/379483/nvidia-x-server-settings-lost-on-every-reboot)            로그인 전 화면에도 설정 적용       아래 명령어를 터미널에 입력하면 된다. gdm은 그래픽 로그인 화면을 관리하는 특수한 유저라고 생각하면 된다.        sudo cp ~/.config/monitors.xml ~gdm/.config/monitors.xml  sudo chown gdm:gdm ~gdm/.config/monitors.xml           왜인지는 모르겠지만 이 방법으로 해결했다는 다른 글들을 보면 한 번에 되지 않고 재부팅을 몇 번씩 해가면서 여러 번 시도해야 했다는 얘기가 있다.       (출처: https://askubuntu.com/questions/1043337/is-there-to-make-the-login-screen-appear-on-the-external-display-in-18-04)      ","categories": ["Others"],
        "tags": ["ubuntu","environment-setup"],
        "url": "/cs-blog/others/Ubuntu-Destop-+-NVIDIA-GPU-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-%EB%93%80%EC%96%BC-%EB%AA%A8%EB%8B%88%ED%84%B0-%EC%84%A4%EC%A0%95/",
        "teaser": null
      },{
        "title": "PostgreSQL-Basics",
        "excerpt":"대충 아래 링크 강의에 나오는 것 정도를 정리했다.   https://www.freecodecamp.org/learn/relational-database/learn-relational-databases-by-building-a-mario-database/build-a-mario-database   DB 접속: psql --username=$USERNAME --dbname=$DBNAME (bash에서)   psql 명령어   앞에 \\ 붙어있는 명령어들은 psql에서 사용하는 명령어들이다.     DB list 확인: \\l   특정 DB 접속: \\c &lt;DB_NAME&gt;   특정 DB에 접속한 상태에서 table list 확인: \\d,   특정 table의 schema 확인: \\d &lt;TABLE_NAME&gt;   SQL 명령어   SQL 쿼리 명령어들 (CREATE, SELECT, INSERT, UPDATE, DELETE 등)은 뒤에 세미콜론을 붙여야 한다.   CREATE      DB 생성:      CREATE DATABASE &lt;db_name&gt;;           Table 생성:      CREATE TABLE &lt;table_name&gt; (column1 datatype [constraint], column2 datatype [constraint], ...);           DROP      Table 삭제:      DROP TABLE &lt;table_name&gt;;           DB 삭제:      DROP DATABASE &lt;db_name&gt;;           INSERT      Tuple 추가:      INSERT INTO &lt;table_name&gt; (column1, column2, ...) VALUES (value1, value2, ...);          한 번에 여러 tuple도 추가할 수 있다.      INSERT INTO &lt;table_name&gt; (column1, column2, ...) VALUES   (value1, value2, ...),    (value1, value2, ...),   ...;           DELETE      Tuple 삭제:      DELETE FROM &lt;table_name&gt; WHERE &lt;condition&gt;;                 Equal은 ==가 아니라 =이다.           ALTER      Table 이름 변경:      ALTER TABLE &lt;table_name&gt; RENAME TO &lt;new_table_name&gt;;           DB 이름 변경:      ALTER DATABASE &lt;db_name&gt; RENAME TO &lt;new_db_name&gt;;           Table scheme 변경:            Column 추가:            ALTER TABLE &lt;table_name&gt; ADD &lt;column_name&gt; &lt;data_type&gt; [&lt;constraint_name&gt;];                             외래 키로 추가               ALTER TABLE &lt;table_name&gt;   ADD COLUMN &lt;column_name&gt; &lt;data_type&gt;   REFERENCES &lt;another_table_name&gt;(&lt;another_column_name&gt;);                                               Column 삭제:            ALTER TABLE &lt;table_name&gt; DROP &lt;column_name&gt;;                       Column 이름 변경:            ALTER TABLE &lt;table_name&gt; RENAME COLUMN &lt;column_name&gt; TO &lt;new_column_name&gt;;                       Column 타입 변경:            ALTER TABLE &lt;table_name&gt; ALTER COLUMN &lt;column_name&gt; TYPE &lt;new_data_type&gt;;                           Column에 constraint 추가:             NOT NULL constraint 추가:            ALTER TABLE &lt;table_name&gt; ALTER COLUMN &lt;column_name&gt; SET NOT NULL;                       UNIQUE constraint 추가:            ALTER TABLE &lt;table_name&gt; ADD CONSTRAINT &lt;constraint_name&gt; UNIQUE (&lt;column_name&gt;);                           특정 Column을 기본 키로 설정:      ALTER TABLE &lt;table_name&gt; ADD PRIMARY KEY (&lt;column_name&gt;);           특정 Column을 외래 키로 설정:      ALTER TABLE &lt;table_name&gt; ADD FOREIGN KEY (&lt;column_name&gt;) REFERENCES &lt;another_table_name&gt;(&lt;another_column_name&gt;);           Update      Tuple 업데이트:      UPDATE &lt;table_name&gt; SET column1 = value1, column2 = value2, ... WHERE &lt;condition&gt;;           SELECT   SELECT column1, column2, ...     FROM &lt;table_name&gt;     [WHERE &lt;condition&gt;]     [ORDER BY column1, column2, ... [ASC|DESC]]     [LIMIT &lt;number&gt;]     ;  group by, having, join, 집계 함수, 중첩 쿼리 같은 것 까지 여기서 설명하긴 너무 길다. 다른 글에서 다루려면 join에 포스트 하나, 집계 함수에 포스트 하나, 중첩 쿼리에 포스트 하나 정도 될 것 같긴 한데…   자료형      int: 다 알고 있을 그거   numeric(precision, scale): 고정소수점 숫자. precision은 전체 자릿수, scale은 소수점 이하 자릿수   serial: auto-incrementing integer   varchar(n): 최대 n글자의 가변 길이 문자열   text: 길이 제한 없는 가변 길이 문자열            문자열은 ‘‘로 감싸야 한다. ““는 table, column 이름 같은 데 사용된다.           boolean: true 또는 false   date: 날짜. YYYY-MM-DD 형식 문자열 직접 입력 가능  ","categories": ["Others"],
        "tags": ["Database","SQL"],
        "url": "/cs-blog/others/PostgreSQL-Basics/",
        "teaser": null
      },{
        "title": "Node.js Build + Test",
        "excerpt":"빌드 환경  HW     Ryzen 5 5600X   DDR4 48GB   text   Native     Ubuntu 24.04   Python 3.12.4   Make 4.3   GCC 13.2.0   Docker 가상환경   text 여기에서 Node.js를 위한 dev container 설정 방법을 알려주고 있다.  docker pull nodejs/devcontainer:nightly docker run -it nodejs/devcontainer:nightly /bin/bash      Ubuntu 22.04   Python 3.10.6   Make 4.3   GCC 11.3.0   빌드 결과   time make -j10   빌드 자체에서 에러는 안 떴다. 아래에 있는 빌드 시간은 Docker에서 돌렸을 때의 시간인데, native로 돌렸을 때도 아마 비슷하게 나왔던 것 같다.  real    20m18.848s user    180m33.354s sys     16m22.906s   테스트 결과  Native   make test-only   Test case 2개에서 에러가 터졌다.   === release test-net-socket-connect-without-cb ===                             Path: parallel/test-net-socket-connect-without-cb node:events:498       throw er; // Unhandled 'error' event       ^  Error: getaddrinfo ENOTFOUND localhost     at GetAddrInfoReqWrap.onlookup [as oncomplete] (node:dns:109:26) Emitted 'error' event on Socket instance at:     at emitErrorNT (node:internal/streams/destroy:170:8)     at emitErrorCloseNT (node:internal/streams/destroy:129:3)     at process.processTicksAndRejections (node:internal/process/task_queues:82:21) {   errno: -3007,   code: 'ENOTFOUND',   syscall: 'getaddrinfo',   hostname: 'localhost' }  Node.js v23.0.0-pre Command: out/Release/node /home/sendol/programming-projects/node/test/parallel/test-net-socket-connect-without-cb.js   === release test-tcp-wrap-listen ===                                           Path: parallel/test-tcp-wrap-listen (node:377826) internal/test/binding: These APIs are for internal testing only. Do not use them. (Use `node --trace-warnings ...` to show where the warning was created) node:events:498       throw er; // Unhandled 'error' event       ^  Error: getaddrinfo ENOTFOUND localhost     at GetAddrInfoReqWrap.onlookup [as oncomplete] (node:dns:109:26) Emitted 'error' event on Socket instance at:     at emitErrorNT (node:internal/streams/destroy:170:8)     at emitErrorCloseNT (node:internal/streams/destroy:129:3)     at process.processTicksAndRejections (node:internal/process/task_queues:82:21) {   errno: -3007,   code: 'ENOTFOUND',   syscall: 'getaddrinfo',   hostname: 'localhost' }  Node.js v23.0.0-pre Command: out/Release/node --expose-internals /home/sendol/programming-projects/node/test/parallel/test-tcp-wrap-listen.js   [05:18|% 100|+ 4154|-   2]: Done                                                Failed tests: out/Release/node /home/sendol/programming-projects/node/test/parallel/test-net-socket-connect-without-cb.js out/Release/node --expose-internals /home/sendol/programming-projects/node/test/parallel/test-tcp-wrap-listen.js make[1]: *** [Makefile:312: jstest] 오류 1 make: *** [Makefile:346: test-only] 오류 2   Docker  Docker에서는 모든 test case가 통과했다.   [03:50|% 100|+ 3878|-   0]: Done                                                All tests passed. make tooltest ..... ---------------------------------------------------------------------- Ran 5 tests in 0.002s  OK  real\t5m59.461s user\t10m28.708s sys\t3m12.673s  ","categories": ["Others"],
        "tags": ["Node.js"],
        "url": "/cs-blog/others/Node.js-Build-+-Test/",
        "teaser": null
      },{
        "title": "Node.js Net.lookupandconnect 버그 수정",
        "excerpt":"일단 저번에 가상환경 밖에서 돌렸을 때 에러가 떴던 테스트의 에러 메세지부터 살펴보자.      node/test/parallel/test-net-socket-connect-without-cb.js ``` === release test-net-socket-connect-without-cb ===                            Path: parallel/test-net-socket-connect-without-cb node:events:498     throw er; // Unhandled ‘error’ event의     ^   Error: getaddrinfo ENOTFOUND localhost     at GetAddrInfoReqWrap.onlookup [as oncomplete] (node:dns:109:26) Emitted ‘error’ event on Socket instance at:     at emitErrorNT (node:internal/streams/destroy:170:8)     at emitErrorCloseNT (node:internal/streams/destroy:129:3)     at process.processTicksAndRejections (node:internal/process/task_queues:82:21) {   errno: -3007,   code: ‘ENOTFOUND’,   syscall: ‘getaddrinfo’,   hostname: ‘localhost’ }   * `node/test/parallel/test-tcp-wrap-listen.js`  === release test-tcp-wrap-listen ===                                          Path: parallel/test-tcp-wrap-listen (node:377826) internal/test/binding: These APIs are for internal testing only. Do not use them. (Use node --trace-warnings ... to show where the warning was created) node:events:498       throw er; // Unhandled ‘error’ event       ^   Error: getaddrinfo ENOTFOUND localhost     at GetAddrInfoReqWrap.onlookup [as oncomplete] (node:dns:109:26) Emitted ‘error’ event on Socket instance at:     at emitErrorNT (node:internal/streams/destroy:170:8)     at emitErrorCloseNT (node:internal/streams/destroy:129:3)     at process.processTicksAndRejections (node:internal/process/task_queues:82:21) {   errno: -3007,   code: ‘ENOTFOUND’,   syscall: ‘getaddrinfo’,   hostname: ‘localhost’ }   `localhost`에 연결을 시도하고 있는 것 같다. `node/test/parallel/test-net-socket-connect-without-cb.js` 코드에 로그를 찍어서 `client.connect` 함수에 뭔 인자가 넘어가는지 한 번 보자.  ```js 'use strict'; const common = require('../common');  // This test ensures that socket.connect can be called without callback // which is optional.  const net = require('net');  const server = net.createServer(common.mustCall(function(conn) {   conn.end();   server.close(); })).listen(0, common.mustCall(function() {   const client = new net.Socket();    client.on('connect', common.mustCall(function() {     client.end();   }));    const address = server.address();   if (!common.hasIPv6 &amp;&amp; address.family === 'IPv6') {     // Necessary to pass CI running inside containers.     client.connect(address.port);   } else {     console.log(address);      // added     client.connect(address);   } }));   Output  {address: '::', family: 'IPv6', port: 38065}   뭔가 이상하다. localhost라는 DNS 주소가 아니라 ::라는 IPv6 주소가 넘어가는데… 또 이상한 게 있는데, 아래 코드를 main branch의 node로 실행시킨 후 nc :: 12345 명령어로 서버에 접속하면 접속이 잘 된다.   'use strict';  const net = require('net');  const server = net.createServer((conn) =&gt; {     conn.write(\"Hello World\\n\");     conn.end();     server.close(); }).listen({     host: '::',     port: 12345,     family: 'IPv6' }, function () {     const client = new net.Socket();      client.on('connect', function () {         // send message and close         client.write(\"Hello World\\n\");         client.end();     });로 });   추가로, 테스트 코드의 에러 내용으로 구글링을 해 보니까 /etc/hosts를 수정해 localhost가 :: 주소로 resolve 될 수 있게 하면 된다고 하는데, 그 전에 Node.js에서 굳이 IP 주소가 아니라 DNS 주소로 연결을 시도하는 것 부터가 문제인 것 같아서 일단 놔두기로 했다.   node/lib/net.js 코드에 있는 net.Socket.connect 함수(node/lib/net.js에서는 프로토타입 함수인 Socket.prototype.connect)에 중단점을 열심히 찍어서 디버깅을 해 봤고, 함수의 마지막인 아래 부분 이전에서는 에러가 안 터지는 걸 찾았다.     if (pipe) {     validateString(path, 'options.path');     defaultTriggerAsyncIdScope(       this[async_id_symbol], internalConnect, this, path,     );   } else {     lookupAndConnect(this, options);   }   return this;   또한 node/test/parallel/test-net-socket-connect-without-cb.js 테스트 코드에서는 else 쪽으로 분기가 되고, lookupAndConnect에 전달되는 options 인자가 테스트 코드의 client.connect(address);와 같다는 것도 발견했다. 정확히는 address가 경우에 따라 약간 전처리가 되고 lookupAndConnect에 전달되는데, 지금의 경우에는 그대로 전달된다.   그래서 lookupAndConnect에도 중단점을 계속 찍어가면서 에러가 발생하는 부분을 찾아봤다. 이 부분이었다. 정확히는 lookup 함수에서 에러가 발생한 후 콜백 함수인 emitLookup에 에러 내용이 전달되고, process.nextTick으로 throwing을 하는 것 같다.     defaultTriggerAsyncIdScope(self[async_id_symbol], function() {     lookup(host, dnsopts, function emitLookup(err, ip, addressType) {       self.emit('lookup', err, ip, addressType, host);        // It's possible we were destroyed while looking this up.       // XXX it would be great if we could cancel the promise returned by       // the look up.       if (!self.connecting) return;        if (err) {         // net.createConnection() creates a net.Socket object and immediately         // calls net.Socket.connect() on it (that's us). There are no event         // listeners registered yet so defer the error event to the next tick.         process.nextTick(connectErrorNT, self, err);       } else if (!isIP(ip)) {         err = new ERR_INVALID_IP_ADDRESS(ip);         process.nextTick(connectErrorNT, self, err);       } else if (addressType !== 4 &amp;&amp; addressType !== 6) {         err = new ERR_INVALID_ADDRESS_FAMILY(addressType,                                              options.host,                                              options.port);         process.nextTick(connectErrorNT, self, err);       } else {         self._unrefTimer();         defaultTriggerAsyncIdScope(           self[async_id_symbol],           internalConnect,           self, ip, port, addressType, localAddress, localPort,         );       }     });   });   위의 코드 블럭에서 lookup에 넘어가는 인자들을 보니까 host는 'localhost'였고, dnsopts에는 IP 버전 정보와 DNS resolver 관련 정보가 들어있었다. 앞서 말했듯 DNS 주소인 localhost가 IPv6 주소로 resolve되도록 hosts 파일을 설정하지 않아서 저런 인자가 넘어가면 에러가 나는 건 이상하지 않은데, 애초에 host에 IP 주소 대신 'localhost'가 들어가는 게 이상하다.   다시 lookupAndConnect 함수를 전체적으로 살펴봤다. 그리고 lookupAndConnect에 인자로 넘어간 options의 options.address 값을 함수 내부에서 전혀 이용하지 않는 것을 발견했다. 그 대신 server.address의 리턴값에는 존재하지 않는 값인 options.host를 사용해서 lookup에 전달될 host를 정의하고 있었다.   function lookupAndConnect(self, options) {   const { localAddress, localPort } = options;   const host = options.host || 'localhost';   let { port, autoSelectFamilyAttemptTimeout, autoSelectFamily } = options;    ...  }   이제 이유는 알아냈으니까 host 값으로 options.address 도 사용할 수 있게 만들자. host 값으로 options.host가 사용되는 것을 가정하고 만든 코드도 많을 테니까 위 코드에서 options.host를 options.address로 바꿔버리면 안 될 것이다. 대신 options.host가 존재하지 않을 때만 options.address 값을 host로 이용하고, options.address 값도 없을 때 이전처럼 host를 'localhost'로 만들면 될 것이다.   function lookupAndConnect(self, options) {   const { localAddress, localPort } = options;   let host = options.host;   if (!host) {     host = options.address;   }   if (!host) {     host = 'localhost';   }   let { port, autoSelectFamilyAttemptTimeout, autoSelectFamily } = options;    ...  }   이러고 다시 bulid 후 test를 돌려보니 처음 고치기로 했던 test-net-socket-connect-without-cb 뿐만 아니라 node/test/parallel/test-tcp-wrap-listen.js 까지 고쳐졌고, 새로 발생한 에러는 없어서 모든 test를 통과했다.   이제 GitHub에 Issue랑 PR을 어떻게 올릴 지 좀 알아봐야 될 것 같다.   그나저나 저런 버그가 있으면 server.address()의 리턴 값 형식으로 서버 주소를 알아왔을 때, localhost가 아닌 서버에 접속하면 항상 에러가 터질 텐데… 이게 어떻게 지금까지 남아있지.  ","categories": ["Others"],
        "tags": ["Node.js"],
        "url": "/cs-blog/others/Node.js-net.lookUpAndConnect-%EB%B2%84%EA%B7%B8-%EC%88%98%EC%A0%95/",
        "teaser": null
      }]
