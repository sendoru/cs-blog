var store = [{
        "title": "Writing The First Post",
        "excerpt":"              Hello, world!는 언제나 국룰이다.   // cpp #include &lt;iostream&gt; int main() {     std::cout &lt;&lt; \"Hello, world!\" &lt;&lt; std::endl;     return 0; }   # python print(\"Hello, world!\")   // Rust use std::io; fn main() {     println!(\"Hello, world!\"); }   console.log(\"Hello, world!\")   To-Do List         ✅ 블로그에 글 하나 올리기       ✅ 블로그 메인 화면 및 사이드바 등에 개인정보 채워두기 (닉네임, 깃헙 링크 등등)       ⬜ 제대로 된 자기소개 페이지 하나 만들기 &lt;- 쓸 거 없어서 못 만드는 중 ㄱ      ✅ 블로그 맨 위에 메뉴 바 만들기       ✅ 블로그 포스트 검색 기능 만들기       ✅ 폰트 및 레이아웃 조절하기. 아직 할 게 좀 남았는데 글 하나 더 써서 기록해둬야겠다.      ✅ 태그 및 기능 추가하기       ❔ 블로그 포스트 연도별 / 카테고리 별 뷰 만들기 &lt;- 반 정도 함       ⬜ 블로그에 HTML로 포스트 올리기 생각보다 구리다. 그냥 MD에 임베드해서 쓰자.       ⬜ Javascript 관련 기능 어떻게 쓰는지 알아보기 나중에 할래   Tips &amp; Troubleshooting           Mardown 파일에 포스트 제목을 따로 쓸 필요는 없다. 굳이 쓰면 이렇게 제목이 두 번 표시된다.                    이미지에 테두리 넣는 법도 배웠다?              Markdown 스타일 List       Markdown에서 1. ... &lt;br&gt; 2. ... &lt;br&gt; ...같은 형태로 글을 쓰면 저절로 ordered list가 된다. ordered list 안의 (plain text를 포함한) 컴포넌트를 작성할 때 들여쓰기를 안 해주면 컴포넌트가 리스트 밖으로 빠져나온다던가 리스트 번호가 1부터 다시 시작한다던가 하는 안 좋은 일이 일어난다. HTML의 &lt;ol&gt; + &lt;li&gt; 등의 태그에서는 스코프가 명확히 정해져 있어서 이런 걸 쓰면 크게 신경 쓸 필요는 없는 일이긴 하다.                     대충 이렇게 된다.              LaTeX 수식       LaTeX로 수식을 써보자.   \\[e^{i \\theta} = \\cos \\theta + i \\sin \\theta\\]      그냥은 안 된다. 다음 코드를 HTML의 &lt;head&gt;에 추가하면 된다.       &lt;head&gt;      &lt;script type=\"text/x-mathjax-config\"&gt;       MathJax.Hub.Config({       tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}       });       &lt;/script&gt;       &lt;script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async&gt;&lt;/script&gt;  &lt;/head&gt;          Markdown으로 작성 중인 경우에는 &lt;head&gt; &lt;/head&gt; 문서 맨 위에 새로 만들어주고 그 안에 저걸 끼워넣으면 된다. 그런데 markdown에서 이렇게 하면 VSCode의 Markdown Preview 확장 프로그램이 맛이 가기 때문에 작성 내용이 어떻게 표시되는지 보고 싶다면 웹 브라우저에서 확인해야 한다.            레이아웃 변경       지금 레이아웃에서 마음에 안 드는 게 몇 가지 있다.                    일반적인 PC 환경인 가로로 길쭉한 화면 상태에서, 글씨가 쓸데없이 커져서 한 화면에 표시되는 정보량이 너무 적어진다. 화면의 가로 길이가 너무 짧다는 생각도 드는데 이것도 폰트 영향일 수도 있어서 폰트부터 고쳐 본 다음에 다시 확인해야 될 것 같다.                   이 정도면 좋을텐데         반응형 UI의 폰트 크기 조절은 _sass/minimal-mistakes/_reset.scss에서 맨 위에 보이는 html 블럭 내의 값들을 바꿔 주면 된다. 가로 폭 조절은 _sass/minimal-mistakes/_variables.scss에서 breakpoints주석 아래에 있는 걸 고쳐주면 된다.            태그 및 카테고리 지정       Markdown 파일 맨 앞에 이렇게 생긴 걸 추가하면 된다.       ---  title: \"Writing The First Post\"  categories:      - Others  tags:      - html      - css      - markup  ---           카테고리를 추가하거나 변경하면 포스트 주소가 바뀐다. 카테고리를 지정하지 않았을 때 주소가 http://sendoru.github.io/cs-blog/writing-the-first-post/였다면, 카테고리를 Others로 바꾼 후에는 http://sendoru.github.io/cs-blog/others/writing-the-first-post/가 된다.       위 문단에서 첫 번째 링크는 접속이 안 되어야 할 것 같은데 캐싱된 게 있는지 예전 페이지로 접속이 된다. 별 상관은 없을 듯            &lt;div&gt; 또는 그 이외의 컨테이너 가운데 정렬        &lt;figure&gt;      &lt;img src=\"/cs-blog/assets/images/writing-the-first-post/image_4.png\" alt=\"\"&gt;      &lt;figcaption&gt; 이 정도면 좋을텐데 &lt;/figcaption&gt;  &lt;/figure&gt;           이렇게 이미지를 넣을 때, 이미지 사이즈를 80%로 줄이고 가운데 정렬로 만드려면  style=\"width: 80%; margin: auto;\" 스타일 속성을 figure에 넣어줘야 한다.       ","categories": ["Others"],
        "tags": ["html","css","markup"],
        "url": "/cs-blog/others/writing-the-first-post/",
        "teaser": null
      },{
        "title": "Writing HTML Post",
        "excerpt":"        Hello, world!                     ","categories": ["Others"],
        "tags": ["html","css"],
        "url": "/cs-blog/others/writing-html-post/",
        "teaser": null
      },{
        "title": "레이아웃 수정 To-Do List",
        "excerpt":"  문제 해결           포스트 페이지 하단의 YOU MAY ALSO ENJOY                     브라우저의 width가 medium일 때 문제가 발생한다.       대충 고쳤다. _sass/minimal-mistakes/_page.scss에서, .page__related에 아래 있는 저걸 추가하면 된다.        @include breakpoint($medium) {      width: 100%;  }                상단바 메뉴                     엄밀히 말하면 문제는 아닌 것 같지만, 메뉴 전체를 보여줄 수 없을 정도로 브라우저 width가 작다면 그냥 오른쪽 위 더보기 메뉴에 모든 메뉴를 몰아넣을 수 있으면 좋을 것 같다. 솔직히 몬가 좀 불편하다.       기능 추가   포스트 기본 스플래시 이미지 / 미리보기 사진 추가   블로그 배너 추가   포스트 목차 추가  ","categories": ["Others"],
        "tags": ["html","css"],
        "url": "/cs-blog/others/%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83-%EC%88%98%EC%A0%95-to-do-list/",
        "teaser": null
      },{
        "title": "Ubuntu Destop + Nvidia Gpu 환경에서 듀얼 모니터 설정",
        "excerpt":"  나는 좀 특이한 구성으로 듀얼 모니터 환경을 세팅해 놨다. 왼쪽에는 1920*1080 해상도의 서브 모니터를 90도 회전시킨 다음 화면 맨 위쪽까지 쳐다보는 게 불편해서 위아래 일부를 잘라놓은 상태로 1080*1440 해상도로 사용하고 있고, 오른쪽에는 2560*1440 해상도의 메인 모니터를 그나마 평범하게 설치해서 사용하고 있다.   NVIDIA X Server를 잘 만져줘서 설정이 제대로 됐다고 생각하고 대충 잘 쓰고 있다가 재부팅을 해 보니 문제가 발생했다. 로그온 화면에서 메인 모니터가 왼쪽 모니터로 설정이 돼 있는지 왼쪽 모니터에 반대 방향으로 90도 돌아간 로그인화면이 떠 있고, 로그인을 하고 나니 메인 모니터는 제대로 잡혔지만 서브 모니터가 1080*1920 사이즈로 화면을 꽉 채우고 있었다.   나중에 Ubuntu를 재설치하거나 다른 PC에 깔 때 삽질하지 않기 위해서 일단 써 둔다.   일단 GPU 드라이버는 설치됐다고 가정하고 글을 쓰겠다. 설치가 안 되어 있다면 이런 글을 참고해서 설치해 주도록 하자.           NVIDIA X Server로 설정 변경       우선 터미널에 sudo nvidia-settings를 쳐서 X Server를 실행시킨다. 듀얼 모니터의 해상도나 모니터 배치 같은 설정은 왼쪽 메뉴에서 X Server Display Configuration을 선택하면 볼 수 있다.       메인 모니터 설정은, 위쪽에서 메인 모니터로 설정할 모니터를 선택하고 Make this the primary display for the X screen을 체크해주면 된다. 모니터를 회전시켜서 사용하는 경우, Orientation의 설정을 바꿔주면 된다.       나처럼 모니터의 일부만 사용할 경우 Advanced… 뷰의 ViewPortIn, ViewPortOut, Panning 옵션을 사용해야 된다.                     ViewPortIn과 Panning에는 모두 출력할 화면의 해상도를 적는다. ViewPortOut은 XsizexYsize+Xoffset+Yoffset 형식이다. 모니터를 회전시키지 않은 상태라면 XsizexYsize 부분에는 ViewPortIn과 Panning에 적은 값을 그대로 적으면 되고, 회전시켰다면 Xsize와 Ysize의 순서를 바꿔서 적으면 된다. Xoffset과 Yoffset은 화면의 표시 위치를 결정하는 변수이다. 잘 조절해 가면서 자신에게 맞는 값을 설정하면 된다.            재부팅 / 다시 로그인 했을 때도 설정 유지       터미널에 sudo nvidia-settings를 쳐서 xorg.conf 파일을 생성한다. 이후 xorg.conf 파일에서 “Device”로 시작하는 블럭을 찾은 후, 아래 내용을 블럭 끝에 붙여넣는다.        Option \"RegistryDwords\" \"PowerMizerEnable=0x1; PerfLevelSrc=0x3322\"           (출처: https://askubuntu.com/questions/379483/nvidia-x-server-settings-lost-on-every-reboot)            로그인 전 화면에도 설정 적용       아래 명령어를 터미널에 입력하면 된다. gdm은 그래픽 로그인 화면을 관리하는 특수한 유저라고 생각하면 된다.        sudo cp ~/.config/monitors.xml ~gdm/.config/monitors.xml  sudo chown gdm:gdm ~gdm/.config/monitors.xml           왜인지는 모르겠지만 이 방법으로 해결했다는 다른 글들을 보면 한 번에 되지 않고 재부팅을 몇 번씩 해가면서 여러 번 시도해야 했다는 얘기가 있다.       (출처: https://askubuntu.com/questions/1043337/is-there-to-make-the-login-screen-appear-on-the-external-display-in-18-04)      ","categories": ["Others"],
        "tags": ["ubuntu","environment-setup"],
        "url": "/cs-blog/others/Ubuntu-Destop-+-NVIDIA-GPU-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-%EB%93%80%EC%96%BC-%EB%AA%A8%EB%8B%88%ED%84%B0-%EC%84%A4%EC%A0%95/",
        "teaser": null
      },{
        "title": "PostgreSQL-Basics",
        "excerpt":"대충 아래 링크 강의에 나오는 것 정도를 정리했다.   https://www.freecodecamp.org/learn/relational-database/learn-relational-databases-by-building-a-mario-database/build-a-mario-database   DB 접속: psql --username=$USERNAME --dbname=$DBNAME (bash에서)   psql 명령어   앞에 \\ 붙어있는 명령어들은 psql에서 사용하는 명령어들이다.     DB list 확인: \\l   특정 DB 접속: \\c &lt;DB_NAME&gt;   특정 DB에 접속한 상태에서 table list 확인: \\d,   특정 table의 schema 확인: \\d &lt;TABLE_NAME&gt;   SQL 명령어   SQL 쿼리 명령어들 (CREATE, SELECT, INSERT, UPDATE, DELETE 등)은 뒤에 세미콜론을 붙여야 한다.   CREATE      DB 생성:      CREATE DATABASE &lt;db_name&gt;;           Table 생성:      CREATE TABLE &lt;table_name&gt; (column1 datatype [constraint], column2 datatype [constraint], ...);           DROP      Table 삭제:      DROP TABLE &lt;table_name&gt;;           DB 삭제:      DROP DATABASE &lt;db_name&gt;;           INSERT      Tuple 추가:      INSERT INTO &lt;table_name&gt; (column1, column2, ...) VALUES (value1, value2, ...);          한 번에 여러 tuple도 추가할 수 있다.      INSERT INTO &lt;table_name&gt; (column1, column2, ...) VALUES   (value1, value2, ...),    (value1, value2, ...),   ...;           DELETE      Tuple 삭제:      DELETE FROM &lt;table_name&gt; WHERE &lt;condition&gt;;                 Equal은 ==가 아니라 =이다.           ALTER      Table 이름 변경:      ALTER TABLE &lt;table_name&gt; RENAME TO &lt;new_table_name&gt;;           DB 이름 변경:      ALTER DATABASE &lt;db_name&gt; RENAME TO &lt;new_db_name&gt;;           Table scheme 변경:            Column 추가:            ALTER TABLE &lt;table_name&gt; ADD &lt;column_name&gt; &lt;data_type&gt; [&lt;constraint_name&gt;];                             외래 키로 추가               ALTER TABLE &lt;table_name&gt;   ADD COLUMN &lt;column_name&gt; &lt;data_type&gt;   REFERENCES &lt;another_table_name&gt;(&lt;another_column_name&gt;);                                               Column 삭제:            ALTER TABLE &lt;table_name&gt; DROP &lt;column_name&gt;;                       Column 이름 변경:            ALTER TABLE &lt;table_name&gt; RENAME COLUMN &lt;column_name&gt; TO &lt;new_column_name&gt;;                       Column 타입 변경:            ALTER TABLE &lt;table_name&gt; ALTER COLUMN &lt;column_name&gt; TYPE &lt;new_data_type&gt;;                           Column에 constraint 추가:             NOT NULL constraint 추가:            ALTER TABLE &lt;table_name&gt; ALTER COLUMN &lt;column_name&gt; SET NOT NULL;                       UNIQUE constraint 추가:            ALTER TABLE &lt;table_name&gt; ADD CONSTRAINT &lt;constraint_name&gt; UNIQUE (&lt;column_name&gt;);                           특정 Column을 기본 키로 설정:      ALTER TABLE &lt;table_name&gt; ADD PRIMARY KEY (&lt;column_name&gt;);           특정 Column을 외래 키로 설정:      ALTER TABLE &lt;table_name&gt; ADD FOREIGN KEY (&lt;column_name&gt;) REFERENCES &lt;another_table_name&gt;(&lt;another_column_name&gt;);           Update      Tuple 업데이트:      UPDATE &lt;table_name&gt; SET column1 = value1, column2 = value2, ... WHERE &lt;condition&gt;;           SELECT   SELECT column1, column2, ...     FROM &lt;table_name&gt;     [WHERE &lt;condition&gt;]     [ORDER BY column1, column2, ... [ASC|DESC]]     [LIMIT &lt;number&gt;]     ;  group by, having, join, 집계 함수, 중첩 쿼리 같은 것 까지 여기서 설명하긴 너무 길다. 다른 글에서 다루려면 join에 포스트 하나, 집계 함수에 포스트 하나, 중첩 쿼리에 포스트 하나 정도 될 것 같긴 한데…   자료형      int: 다 알고 있을 그거   numeric(precision, scale): 고정소수점 숫자. precision은 전체 자릿수, scale은 소수점 이하 자릿수   serial: auto-incrementing integer   varchar(n): 최대 n글자의 가변 길이 문자열   text: 길이 제한 없는 가변 길이 문자열            문자열은 ‘‘로 감싸야 한다. ““는 table, column 이름 같은 데 사용된다.           boolean: true 또는 false   date: 날짜. YYYY-MM-DD 형식 문자열 직접 입력 가능  ","categories": ["Others"],
        "tags": ["Database","SQL"],
        "url": "/cs-blog/others/PostgreSQL-Basics/",
        "teaser": null
      },{
        "title": "Node.js Build + Test",
        "excerpt":"빌드 환경  HW     Ryzen 5 5600X   DDR4 48GB   text   Native     Ubuntu 24.04   Python 3.12.4   Make 4.3   GCC 13.2.0   Docker 가상환경   text 여기에서 Node.js를 위한 dev container 설정 방법을 알려주고 있다.  docker pull nodejs/devcontainer:nightly docker run -it nodejs/devcontainer:nightly /bin/bash      Ubuntu 22.04   Python 3.10.6   Make 4.3   GCC 11.3.0   빌드 결과   time make -j10   빌드 자체에서 에러는 안 떴다. 아래에 있는 빌드 시간은 Docker에서 돌렸을 때의 시간인데, native로 돌렸을 때도 아마 비슷하게 나왔던 것 같다.  real    20m18.848s user    180m33.354s sys     16m22.906s   테스트 결과  Native   make test-only   Test case 2개에서 에러가 터졌다.   === release test-net-socket-connect-without-cb ===                             Path: parallel/test-net-socket-connect-without-cb node:events:498       throw er; // Unhandled 'error' event       ^  Error: getaddrinfo ENOTFOUND localhost     at GetAddrInfoReqWrap.onlookup [as oncomplete] (node:dns:109:26) Emitted 'error' event on Socket instance at:     at emitErrorNT (node:internal/streams/destroy:170:8)     at emitErrorCloseNT (node:internal/streams/destroy:129:3)     at process.processTicksAndRejections (node:internal/process/task_queues:82:21) {   errno: -3007,   code: 'ENOTFOUND',   syscall: 'getaddrinfo',   hostname: 'localhost' }  Node.js v23.0.0-pre Command: out/Release/node /home/sendol/programming-projects/node/test/parallel/test-net-socket-connect-without-cb.js   === release test-tcp-wrap-listen ===                                           Path: parallel/test-tcp-wrap-listen (node:377826) internal/test/binding: These APIs are for internal testing only. Do not use them. (Use `node --trace-warnings ...` to show where the warning was created) node:events:498       throw er; // Unhandled 'error' event       ^  Error: getaddrinfo ENOTFOUND localhost     at GetAddrInfoReqWrap.onlookup [as oncomplete] (node:dns:109:26) Emitted 'error' event on Socket instance at:     at emitErrorNT (node:internal/streams/destroy:170:8)     at emitErrorCloseNT (node:internal/streams/destroy:129:3)     at process.processTicksAndRejections (node:internal/process/task_queues:82:21) {   errno: -3007,   code: 'ENOTFOUND',   syscall: 'getaddrinfo',   hostname: 'localhost' }  Node.js v23.0.0-pre Command: out/Release/node --expose-internals /home/sendol/programming-projects/node/test/parallel/test-tcp-wrap-listen.js   [05:18|% 100|+ 4154|-   2]: Done                                                Failed tests: out/Release/node /home/sendol/programming-projects/node/test/parallel/test-net-socket-connect-without-cb.js out/Release/node --expose-internals /home/sendol/programming-projects/node/test/parallel/test-tcp-wrap-listen.js make[1]: *** [Makefile:312: jstest] 오류 1 make: *** [Makefile:346: test-only] 오류 2   Docker  Docker에서는 모든 test case가 통과했다.   [03:50|% 100|+ 3878|-   0]: Done                                                All tests passed. make tooltest ..... ---------------------------------------------------------------------- Ran 5 tests in 0.002s  OK  real\t5m59.461s user\t10m28.708s sys\t3m12.673s  ","categories": ["Others"],
        "tags": ["Node.js"],
        "url": "/cs-blog/others/Node.js-Build-+-Test/",
        "teaser": null
      },{
        "title": "Node.js Net.lookupandconnect 버그 수정",
        "excerpt":"일단 저번에 가상환경 밖에서 돌렸을 때 에러가 떴던 테스트의 에러 메세지부터 살펴보자.      node/test/parallel/test-net-socket-connect-without-cb.js   === release test-net-socket-connect-without-cb ===                             Path: parallel/test-net-socket-connect-without-cb node:events:498       throw er; // Unhandled 'error' event       ^  Error: getaddrinfo ENOTFOUND localhost     at GetAddrInfoReqWrap.onlookup [as oncomplete] (node:dns:109:26) Emitted 'error' event on Socket instance at:     at emitErrorNT (node:internal/streams/destroy:170:8)     at emitErrorCloseNT (node:internal/streams/destroy:129:3)     at process.processTicksAndRejections (node:internal/process/task_queues:82:21) {   errno: -3007,   code: 'ENOTFOUND',   syscall: 'getaddrinfo',   hostname: 'localhost' }      node/test/parallel/test-tcp-wrap-listen.js   === release test-tcp-wrap-listen ===                                           Path: parallel/test-tcp-wrap-listen (node:377826) internal/test/binding: These APIs are for internal testing only. Do not use them. (Use `node --trace-warnings ...` to show where the warning was created) node:events:498       throw er; // Unhandled 'error' event       ^  Error: getaddrinfo ENOTFOUND localhost     at GetAddrInfoReqWrap.onlookup [as oncomplete] (node:dns:109:26) Emitted 'error' event on Socket instance at:     at emitErrorNT (node:internal/streams/destroy:170:8)     at emitErrorCloseNT (node:internal/streams/destroy:129:3)     at process.processTicksAndRejections (node:internal/process/task_queues:82:21) {   errno: -3007,   code: 'ENOTFOUND',   syscall: 'getaddrinfo',   hostname: 'localhost' }   localhost에 연결을 시도하고 있는 것 같다. node/test/parallel/test-net-socket-connect-without-cb.js 코드에 로그를 찍어서 client.connect 함수에 뭔 인자가 넘어가는지 한 번 보자.   'use strict'; const common = require('../common');  // This test ensures that socket.connect can be called without callback // which is optional.  const net = require('net');  const server = net.createServer(common.mustCall(function(conn) {   conn.end();   server.close(); })).listen(0, common.mustCall(function() {   const client = new net.Socket();    client.on('connect', common.mustCall(function() {     client.end();   }));    const address = server.address();   if (!common.hasIPv6 &amp;&amp; address.family === 'IPv6') {     // Necessary to pass CI running inside containers.     client.connect(address.port);   } else {     console.log(address);      // added     client.connect(address);   } }));   Output  {address: '::', family: 'IPv6', port: 38065}   뭔가 이상하다. localhost라는 DNS 주소가 아니라 ::라는 IPv6 주소가 넘어가는데… 또 이상한 게 있는데, 아래 코드를 main branch의 node로 실행시킨 후 nc :: 12345 명령어로 서버에 접속하면 접속이 잘 된다.   'use strict';  const net = require('net');  const server = net.createServer((conn) =&gt; {     conn.write(\"Hello World\\n\");     conn.end();     server.close(); }).listen({     host: '::',     port: 12345,     family: 'IPv6' }, function () {     const client = new net.Socket();      client.on('connect', function () {         // send message and close         client.write(\"Hello World\\n\");         client.end();     });로 });   추가로, 테스트 코드의 에러 내용으로 구글링을 해 보니까 /etc/hosts를 수정해 localhost가 :: 주소로 resolve 될 수 있게 하면 된다고 하는데, 그 전에 Node.js에서 굳이 IP 주소가 아니라 DNS 주소로 연결을 시도하는 것 부터가 문제인 것 같아서 일단 놔두기로 했다.   node/lib/net.js 코드에 있는 net.Socket.connect 함수(node/lib/net.js에서는 프로토타입 함수인 Socket.prototype.connect)에 중단점을 열심히 찍어서 디버깅을 해 봤고, 함수의 마지막인 아래 부분 이전에서는 에러가 안 터지는 걸 찾았다.     if (pipe) {     validateString(path, 'options.path');     defaultTriggerAsyncIdScope(       this[async_id_symbol], internalConnect, this, path,     );   } else {     lookupAndConnect(this, options);   }   return this;   또한 node/test/parallel/test-net-socket-connect-without-cb.js 테스트 코드에서는 else 쪽으로 분기가 되고, lookupAndConnect에 전달되는 options 인자가 테스트 코드의 client.connect(address);와 같다는 것도 발견했다. 정확히는 address가 경우에 따라 약간 전처리가 되고 lookupAndConnect에 전달되는데, 지금의 경우에는 그대로 전달된다.   그래서 lookupAndConnect에도 중단점을 계속 찍어가면서 에러가 발생하는 부분을 찾아봤다. 이 부분이었다. 정확히는 lookup 함수에서 에러가 발생한 후 콜백 함수인 emitLookup에 에러 내용이 전달되고, process.nextTick으로 throwing을 하는 것 같다.     defaultTriggerAsyncIdScope(self[async_id_symbol], function() {     lookup(host, dnsopts, function emitLookup(err, ip, addressType) {       self.emit('lookup', err, ip, addressType, host);        // It's possible we were destroyed while looking this up.       // XXX it would be great if we could cancel the promise returned by       // the look up.       if (!self.connecting) return;        if (err) {         // net.createConnection() creates a net.Socket object and immediately         // calls net.Socket.connect() on it (that's us). There are no event         // listeners registered yet so defer the error event to the next tick.         process.nextTick(connectErrorNT, self, err);       } else if (!isIP(ip)) {         err = new ERR_INVALID_IP_ADDRESS(ip);         process.nextTick(connectErrorNT, self, err);       } else if (addressType !== 4 &amp;&amp; addressType !== 6) {         err = new ERR_INVALID_ADDRESS_FAMILY(addressType,                                              options.host,                                              options.port);         process.nextTick(connectErrorNT, self, err);       } else {         self._unrefTimer();         defaultTriggerAsyncIdScope(           self[async_id_symbol],           internalConnect,           self, ip, port, addressType, localAddress, localPort,         );       }     });   });   위의 코드 블럭에서 lookup에 넘어가는 인자들을 보니까 host는 'localhost'였고, dnsopts에는 IP 버전 정보와 DNS resolver 관련 정보가 들어있었다. 앞서 말했듯 DNS 주소인 localhost가 IPv6 주소로 resolve되도록 hosts 파일을 설정하지 않아서 저런 인자가 넘어가면 에러가 나는 건 이상하지 않은데, 애초에 host에 IP 주소 대신 'localhost'가 들어가는 게 이상하다.   다시 lookupAndConnect 함수를 전체적으로 살펴봤다. 그리고 lookupAndConnect에 인자로 넘어간 options의 options.address 값을 함수 내부에서 전혀 이용하지 않는 것을 발견했다. 그 대신 server.address의 리턴값에는 존재하지 않는 값인 options.host를 사용해서 lookup에 전달될 host를 정의하고 있었다.   function lookupAndConnect(self, options) {   const { localAddress, localPort } = options;   const host = options.host || 'localhost';   let { port, autoSelectFamilyAttemptTimeout, autoSelectFamily } = options;    ...  }   이제 이유는 알아냈으니까 host 값으로 options.address 도 사용할 수 있게 만들자. host 값으로 options.host가 사용되는 것을 가정하고 만든 코드도 많을 테니까 위 코드에서 options.host를 options.address로 바꿔버리면 안 될 것이다. 대신 options.host가 존재하지 않을 때만 options.address 값을 host로 이용하고, options.address 값도 없을 때 이전처럼 host를 'localhost'로 만들면 될 것이다.   function lookupAndConnect(self, options) {   const { localAddress, localPort } = options;   let host = options.host;   if (!host) {     host = options.address;   }   if (!host) {     host = 'localhost';   }   let { port, autoSelectFamilyAttemptTimeout, autoSelectFamily } = options;    ...  }   이러고 다시 bulid 후 test를 돌려보니 처음 고치기로 했던 test-net-socket-connect-without-cb 뿐만 아니라 node/test/parallel/test-tcp-wrap-listen.js 까지 고쳐졌고, 새로 발생한 에러는 없어서 모든 test를 통과했다.   이제 GitHub에 Issue랑 PR을 어떻게 올릴 지 좀 알아봐야 될 것 같다.   그나저나 저런 버그가 있으면 server.address()의 리턴 값 형식으로 서버 주소를 알아왔을 때, localhost가 아닌 서버에 접속하면 항상 에러가 터질 텐데… 이게 어떻게 지금까지 남아있지.  ","categories": ["Others"],
        "tags": ["Node.js"],
        "url": "/cs-blog/others/Node.js-net.lookUpAndConnect-%EB%B2%84%EA%B7%B8-%EC%88%98%EC%A0%95/",
        "teaser": null
      },{
        "title": "Node.js + V8",
        "excerpt":"Node.js repo의 ./src 디렉토리에 가 보면, 시스템 콜 사용 같은 저레벨 작업이나 퍼포먼스 향상을 위해 C++로 작성된 코드가 보일 것이다. 그리고 이 코드들을 까 보면 v8 네임스페이스의 뭔가로 가득 차 있어 C++만 잘 한다고 코드를 이해하기가 쉽지 않다. 이 글에서는 V8이 무엇인지, Node.js와 어떤 관계가 있는지, 그리고 Node.js의 C++ 코드를 이해하는데 도움이 되는 V8의 핵심 개념들을 살펴보겠다.   V8이란 무엇인가?   V8은 구글에서 개발한 C++ 기반의 오픈소스 JavaScript 엔진이다. JavaScript 엔진은 JavaScript 코드를 해석하고 실행하는 프로그램이다. V8은 웹 브라우저인 크롬의 핵심 엔진으로 사용되며, Node.js도 V8을 사용하여 JavaScript 코드를 실행한다.   JavaScript 런타임 환경의 일종이라고 하는 Node.js도 자바스크립트를 실행하는 프로그램인데, 런타임 환경과 엔진의 차이는 구체적으로 다음과 같다. JavaScript 엔진은 일종의 인터프리터 또는 컴파일러에 해당된다. ECMAScript 표준에 따라 JavaScript 코드를 해석하고 실행하는 역할을 하지만, 파일 I/O나 네트워크 요청 같은 시스템 레벨의 기능은 제공하지 않는다. 런타임 환경은 이러한 엔진을 포함하며, 바닐라 JavaScript 외에도 브라우저의 DOM API나 Node.js의 fs 모듈 같은 기능을 제공하여 더 넓은 용도로 사용할 수 있게 한다.   V8의 다른 중요한 기능은, C++ 코드와 JavaScript 코드 간의 상호작용을 가능하게 하는 바인딩이다. 이를 통해 C++로 작성된 코드에서 JavaScript 함수를 호출하거나, JavaScript 코드에서 C++ 함수를 호출할 수 있다. Node.js의 C++ 코드는 이러한 바인딩을 통해 V8의 기능을 활용하여 JavaScript 코드와 상호작용한다.   이제 V8의 핵심 개념을 살펴보고, 이를 통해 JavaScript 코드에서 불러올 수 있는 C++ 함수가 어떻게 작성되는지 알아보자.   V8의 핵심 개념   Isolate   v8::Isolate 클래스는 V8에서 작동되는 하나의 JavaScript 실행 환경을 나타낸다. 각 Isolate는 자신만의 메모리 공간을 가지며, 서로 다른 Isolate 간에는 데이터를 공유할 수 없다. 이는 JavaScript 코드가 실행되는 환경을 격리시켜, 서로 다른 Isolate 간에는 데이터 누출이나 충돌이 발생하지 않도록 한다.   Node.js에서는 각 요청이나 연결마다 새로운 Isolate를 생성하여 격리를 유지한다. 이를 통해 하나의 요청이 다른 요청에 영향을 미치지 않도록 보장한다.   Context   v8::Context 클래스는 JavaScript 코드가 실행되는 환경을 나타낸다. Context는 Isolate 내에 생성되며, 여러 개의 Context를 생성하여 각각의 JavaScript 코드를 실행할 수 있다. Context는 JavaScript 코드가 실행되는 환경을 나타내므로, Context를 통해 JavaScript 코드에서 사용할 수 있는 전역 객체나 함수 등을 정의할 수 있다.   V8 JavaScript Value   V8은 JavaScript의 값들을 C++에서 사용할 수 있는 형태로 표현하기 위해 v8::Value 클래스를 사용한다. v8::Value 클래스는 JavaScript의 모든 자료형에 대응되며, 특정한 자료형을 나타내고 싶다면 서브클래스인 v8::String, v8::Number, v8::Object 등을 사용한다. Value의 실제 값을 C++의 타입으로 변환하기 위해서는 Value 객체를 적절한 서브클래스로 캐스팅한 후, .Value() 메소드를 사용한다.   Value handle   JavaScript value는 v8::Value 객체로 표현되며, 이 객체를 다루기 위해 handle이라는 일종의 포인터를 사용한다. v8::Value 객체는 Local, Global, 두 가지 타입의 handle을 가질 수 있다.   Local handle   v8::Local&lt;T&gt; handle은 v8::Value 객체를 가리키는 임시 포인터이다. 특정 스코프 내에서만 유효하며, 스코프를 벗어나면 자동으로 해제된다. 주로 함수 내의 지역 변수로 사용된다.   Local handle이 생성되기 이전에, v8::HandleScope나 v8::EscapableHandleScope 객체가 스택에 존재해야 한다. Local handle은 이 스코프에 추가되며, 스코프와 함께 삭제된다. EscapableHandleScope는 HandleScope와 달리 Local handle을 반환할 수 있으며, 이를 통해 handle을 다른 스코프로 넘길 수 있다.   단, binding 함수 내에서 Local handle을 사용할 때는 이미 함수 밖에 HandleScope가 존재하므로, 다른 스코프를 생성할 필요가 없다.   간단한 JavaScript 코드와 그에 대응되는 C++ 코드를 살펴보자.   function getFoo(obj) {   return obj.foo; }   v8::Local&lt;v8::Value&gt; GetFoo(v8::Local&lt;v8::Context&gt; context,                             v8::Local&lt;v8::Object&gt; obj) {   v8::Isolate* isolate = context-&gt;GetIsolate();   v8::EscapableHandleScope handle_scope(isolate);    // The 'foo_string' handle cannot be returned from this function because   // it is not “escaped” with `.Escape()`.   v8::Local&lt;v8::String&gt; foo_string =       v8::String::NewFromUtf8(isolate, \"foo\").ToLocalChecked();    v8::Local&lt;v8::Value&gt; return_value;   if (obj-&gt;Get(context, foo_string).ToLocal(&amp;return_value)) {     return handle_scope.Escape(return_value);   } else {     // There was a JS exception! Handle it somehow.     return v8::Local&lt;v8::Value&gt;();   } }   Global handle   v8::Global&lt;T&gt; handle은 JavaScript 엔진이 종료되지 않는 한 계속 유지될 수 있는 포인터이다. 전역 변수나 모듈 변수 같이 계속 사용되는 값들에 사용된다.   Global handle에는 strong과 weak 두 가지 타입이 있다. strong handle은 JavaScript 엔진이 종료되지 않는 한 계속 유지되는 반면, weak handle은 다른 값에 의해 참조되지 않으면 자동으로 해제된다.   Exception handling   V8은 C++의 exception을 JavaScript에 직접 bind할 수 없다. 그 대신 Maybe 타입을 사용하거나 TryCatch 객체를 사용하여 JavaScript 코드에서 발생한 예외를 처리할 수 있다.   Maybe, MaybeLocal 타입   V8의 Maybe&lt;T&gt;와 MaybeLocal&lt;T&gt; 타입은 반환값이 있을 수도 있고 없을 수도 있는 함수의 반환값을 나타낸다. std::optional과 비슷한 것이라고 보면 된다. Maybe&lt;T&gt;의 값이 비어 있는 경우 (.IsNothing()이 true인 경우)는 예외가 발생한 것으로 간주할 수 있다. 함수의 반환 타입이 Maybe&lt;T&gt;인 경우, 함수 내부에서 서브클래스인 Just&lt;T&gt;나 Nothing&lt;T&gt;을 반환하여 값을 반환하거나 예외를 처리할 수 있다.   MaybeLocal&lt;T&gt;는 Local handle을 반환하는 함수의 반환 타입으로 사용된다. MaybeLocal&lt;T&gt;는 Maybe&lt;T&gt;와 비슷하게 동작하지만, Local handle을 반환한다는 점이 다르고 메소드 이름에도 차이가 있다.                  Maybe       MaybeLocal                       maybe.IsNothing()       maybe_local.IsEmpty()                 maybe.IsJust()       !maybe_local.IsEmpty()                 maybe.To(&amp;value)       maybe_local.ToLocal(&amp;local)                 maybe.ToChecked()       maybe_local.ToLocalChecked()                 maybe.FromJust()       maybe_local.ToLocalChecked()                 maybe.Check()       –                 v8::Nothing&lt;T&gt;()       v8::MaybeLocal&lt;T&gt;()                 v8::Just&lt;T&gt;(value)       v8::MaybeLocal&lt;T&gt;(value)           TryCatch 객체   Funtion binding   이제 binding funciton을 쓰기 위한 정말 기초적인 것들은 살펴봤다. 이제 실제로 JavaScript 코드에서 불러올 수 있는 C++ 함수를 작성해보자.   JavaScript에 노출되는 C++ 함수는 다음과 같은 형태를 가진다. 아래 함수는 node_util.cc 파일에 정의된 함수로, ArrayBufferView 객체가 주어졌을 때 해당 객체가 버퍼를 가지고 있는지 확인하는 함수이다.   void ArrayBufferViewHasBuffer(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {   CHECK(args[0]-&gt;IsArrayBufferView());   args.GetReturnValue().Set(args[0].As&lt;ArrayBufferView&gt;()-&gt;HasBuffer()); }   (네임스페이스는 using v8;로 설정되어 있다고 가정한다.)   args는 JavaScript 함수에 전달된 전체 인자를 담고 있고, args[i]는 i번째 (0-based) 인자를 나타낸다. args.GetReturnValue()는 함수의 반환값을 설정하는데 사용되며, Set() 메소드를 통해 반환값을 설정한다.   이 함수를 JavaScript에서 사용하려면 다음과 같이 SetMethod, SetMethodNoSideEffect 등의 함수를 이용해 Node.js의 target 객체에 함수를 등록해야 한다.   void Initialize(Local&lt;Object&gt; target,                 Local&lt;Value&gt; unused,                 Local&lt;Context&gt; context,                 void* priv) {   Environment* env = Environment::GetCurrent(context);    SetMethod(context, target, \"getaddrinfo\", GetAddrInfo);   // ... }  NODE_MODULE_CONTEXT_AWARE(NODE_GYP_MODULE_NAME, Initialize);   이제 기존에 존재하는 모듈에 SumNumbers라는 함수를 추가해보자. 이 함수는 배열을 받아 배열의 모든 요소를 더한 값을 반환하며, 배열의 요소가 숫자가 아닌 경우 예외를 발생시킨다.   // This could also return a v8::MaybeLocal&lt;v8::Number&gt;, for example. v8::Maybe&lt;double&gt; SumNumbers(v8::Local&lt;v8::Context&gt; context,                              v8::Local&lt;v8::Array&gt; array_of_integers) {   v8::Isolate* isolate = context-&gt;GetIsolate();   v8::HandleScope handle_scope(isolate);    double sum = 0;    for (uint32_t i = 0; i &lt; array_of_integers-&gt;Length(); i++) {     v8::Local&lt;v8::Value&gt; entry;     if (!array_of_integers-&gt;Get(context, i).ToLocal(&amp;entry)) {       // Oops, we might have hit a getter that throws an exception!       // It's better to not continue return an empty (“nothing”) Maybe.       return v8::Nothing&lt;double&gt;();     }      if (!entry-&gt;IsNumber()) {       // Let's just skip any non-numbers. It would also be reasonable to throw       // an exception here, e.g. using the error system in src/node_errors.h,       // and then to return an empty Maybe again.       continue;     }      // This cast is valid, because we've made sure it's really a number.     v8::Local&lt;v8::Number&gt; entry_as_number = entry.As&lt;v8::Number&gt;();      sum += entry_as_number-&gt;Value();   }    return v8::Just(sum); }  // Function that is exposed to JS: void SumNumbers(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args) {   // This will crash if the first argument is not an array. Let's assume we   // have performed type checking in a JavaScript wrapper function.   CHECK(args[0]-&gt;IsArray());    double sum;   if (!SumNumbers(args.GetIsolate()-&gt;GetCurrentContext(),                   args[0].As&lt;v8::Array&gt;()).To(&amp;sum)) {     // Exception was thrown     // Nothing to do, we can just return directly to JavaScript.     return;   }    args.GetReturnValue().Set(sum); }   첫 번째 함수는 배열의 합을 구하는 실제 로직이 담겨 있는 함수로, 다른 함수에서의 예외 처리를 위해 Maybe 타입을 반환한다. 두 번째 함수는 JavaScript와 실제로 binding되는 wrapper 함수로, Maybe 타입을 처리하여 JavaScript에 반환한다.   두 번째 함수의 if문 내 조건식이 !SumNumbers(...).To(&amp;sum)인 이유는, SumNumbers 함수가 Maybe 타입을 반환하기 때문이다. To 메소드는 Maybe 타입을 받아서 그 안에 있는 값을 sum에 넣어주는 역할을 한다. 만약 SumNumbers 함수가 Nothing을 반환한다면, To 메소드는 false를 반환하고 sum에는 아무 값도 들어가지 않는다.   이제 이 함수를 Node.js에서 사용할 수 있도록 target 객체에 등록하면 된다.   void Initialize(Local&lt;Object&gt; target,                 Local&lt;Value&gt; unused,                 Local&lt;Context&gt; context,                 void* priv) {   Environment* env = Environment::GetCurrent(context);    /*   / Other functions...   */    SetMethod(context, target, \"sumNumbers\", SumNumbers); }   마지막으로, js 파일에서 이 함수를 사용할 수 있도록 sumNumbers 함수를 등록하면 된다.   const { sumNumbers } = internalBinding(\"MODULE_NAME\");   주의할 점으로, C++ 코드의 주석에도 있지만 SumNumbers 함수로 들어오는 인자가 Array 타입이 아닌 경우에 대한 예외 처리가 없다. 이는 JavaScript 코드에서 미리 타입 체크를 하고 넘겨주는 것이 좋다.   어쩌다 보니 Node.js의 Node.js C++ codebase 공식 문서를 번역해서 libuv 내용 날린 다음에 압축해 놓은 것 같은 글이 됐는데 글이 꽤 길어졌다. 그 와중에 메모리 관리, bootstrap 과정에서의 C++ binding 로딩 등 빠진 내용도 좀 있다. 나중에 시간나면 더 살펴봐야겠다.      이 글의 코드 대부분은 Node.js C++ codebase 공식 문서에서 가져왔다.  ","categories": ["Others"],
        "tags": ["Node.js"],
        "url": "/cs-blog/others/Node.js-+-V8/",
        "teaser": null
      },{
        "title": "Tree Dp 시간복잡도 분석",
        "excerpt":"Tree DP를 DFS를 이용해 구현할 때, 실제 시간복잡도는 코드를 보고 대충 생각한 것보다 작은 경우가 많다. 이 글에서는 그런 몇몇 케이스를 다룬다.   자식 노드의 결과를 합칠 때 자식 서브트리 크기에 대한 다항식 시간이 걸릴 경우   보통 Tree DP는 다음과 비슷한 함수를 만들고 루트 노드를 함수 인자로 넘겨 실행하면 풀 수 있다.   void dfs(int node) {     (dp_table[node] 초기화);     for (int next : children[node]) {         dfs(next);     }     (dp_table[next]들의 값을 이용해 dp_table[node] 계산); } dfs(root_node);   노드 갯수가 $N$개인 트리에서 노드 $n$의 자식이 $k_n$개 있고, 이 자식들을 루트로 하는 $k$개의 서브트리의 크기가 각각 $|s^n_1|$, $|s^n_2|$, … , $|s^n_{k_n}|$라 해 보자.   함수 마지막에서 자식 노드의 결과를 합치는데, 이 과정의 시간복잡도가 $|s^n_i| (1 \\leq i \\leq k_n)$에 대한 이차식이 되는 경우를 생각해보자.   최악의 경우 각 노드에 대해 각 $|s_i|$가 $O(N)$, 노드를 합치는 횟수가 $O(N)$이므로 dfs(root_node)의 시간복잡도는 $O(N^3)$이 될 것 같지만, 실제로는 $O(N^2)$가 된다.   $n$이 루트인 서브트리의 크기를 $|n|$, 이 노드의 결과를 구하는 시간을 $T(n)$이라 해 보자.   또한 자식 노드들의 결과를 합치는 시간복잡도가 $O(이차식)$이라는 것은, 자식 노드 $s^n_1$, $s^n_2$, … 의 결과를 합치는 데 $\\sum_{1 \\leq i \\leq j \\leq k_n} c |s^n_i| |s^n_j|$ ($c$는 상수) 이하의 시간이 걸린다는 뜻이다.    $n$의 자식들 $s^n_i$에 대해 $T(s^n_i) \\leq d|s^n_i|^2 = O(|s^n_i|^2)$ ($d는 상수) 라고 가정해 보자. 그러면,   \\[\\begin{split} &amp;T(n) \\\\ &amp;= \\sum_{1 \\leq i \\leq j \\leq k_n} c \\|s^n_i\\| \\|s^n_j\\| + \\sum_{1 \\leq i \\leq k_n} T(s^n_i) \\\\ &amp;\\leq \\sum_{1 \\leq i \\leq j \\leq k_n} c \\|s^n_i\\| \\|s^n_j\\| + \\sum_{1 \\leq i \\leq k_n} d\\|s^n_i\\|^2 \\\\ &amp;= \\sum_{1 \\leq i \\lt j \\leq k_n} c\\|s^n_i\\| \\|s^n_j\\| + \\sum_{1 \\leq i \\leq k_n} (c+d)\\|s^n_i\\|^2 \\\\ &amp;\\leq \\sum_{1 \\leq i \\lt j \\leq k_n} 2e \\|s^n_i\\| \\|s^n_j\\| + \\sum_{1 \\leq i \\leq k_n} e\\|s^n_i\\|^2 \\quad \\quad ({e &gt; c + d}) \\\\ &amp;= e \\left( \\sum_{1 \\leq i \\leq k_n} \\|s^n_i\\| \\right) ^ 2 \\\\ &amp;= e (\\|n\\|- 1)^2 = O(\\|n\\|^2) \\end{split}\\]  가 되어 노드 $n$에 대해서도 $T(n) = O(|n|^2)$가 성립한다.   또한 base case인 리프 노드에 대해서는 $T(|n|) = O(1) &lt; O(|n|^2)$ 이므로, 수학적 귀납법에 의해 전체 문제를 $O(N)$ 시간에 풀 수 있다.   저걸 잘 일반화하면, 자식 노드의 결과를 합치는 시간복잡도가 $|s^n_1|$, $|s^n_2|$, … , $|s^n_{k_n}|$ 에 대한 $p$차식이면, 전체 문제를 $O(N^p)$ 시간에 풀 수 있다는 것도 알 수 있다.   자식 노드를 합칠 때 자식 노드의 갯수에 대한 다항식 시간이 걸릴 경우   대충 이런 경우를 생각해보자.   void dfs(int node) {     (dp_table[node] 초기화);     for (int next : children[node]) {         dfs(next);     }     for (int next1 : children[node]) {         for(int next2 : children[node]) {             dp_table[node] = foo(dp_table[next1], dp_table[next2]);         }     } } dfs(root_node);   이때 함수 foo는 O(1) 시간에 실행된다고 하자.   이것도 대충 보면 위와 비슷한 이유로 $O(N^3)$ 시간이 걸릴 것 같다. 하지만 이것도 $O(N^2)$다.   위와 마찬가지로, $n$이 루트인 서브트리의 크기를 $|n|$, 이 노드의 자식 노드의 갯수를 $k_n$, 이 노드의 결과를 구하는 시간을 $T(n)$이라 해 보자.   자식 노드들의 결과를 합치는 시간복잡도는 $O({k_n}^2)$, 즉 $c{k_n}^2$ 이하이다 ($c$는 상수).   임의의 노드 $n$의 자식들 $s^n_i$에 대해 $T(s^n_i) \\leq d|s^n_i|^2 = O(|s^n_i|^2)$ ($d는 상수) 라고 가정해 보자. 그러면,   \\[\\begin{split} &amp;T(n) \\\\ &amp;= c{k_n}^2 + \\sum_{1 \\leq i \\leq k_n} T(s^n_i) \\\\ &amp;\\leq c{k_n}^2 + \\sum_{1 \\leq i \\leq k_n} d\\|s^n_i\\|^2 \\\\ &amp;= c \\left( \\sum_{1 \\leq i \\leq k_n} 1 \\right) ^ 2+\\sum_{1 \\leq i \\leq k_n} d\\|s^n_i\\|^2 \\\\ &amp;\\leq c \\left( \\sum_{1 \\leq i \\leq k_n} \\|s^n_i\\| \\right) ^ 2+\\sum_{1 \\leq i \\leq k_n} d\\|s^n_i\\|^2 \\\\ &amp;\\leq e \\left( \\sum_{1 \\leq i \\leq k_n} \\|s^n_i\\| \\right) ^ 2+\\sum_{1 \\leq i \\leq k_n} e\\|s^n_i\\|^2 \\quad \\quad ({e &gt; c + d}) \\\\ &amp;\\leq 2e \\left( \\sum_{1 \\leq i \\leq k_n} \\|s^n_i\\| \\right) ^ 2 \\\\ &amp;= 2e (\\|n\\|- 1)^2 = O(\\|n\\|^2) \\end{split}\\]  가 되어 위와 마찬가지로 수학적 귀납법에 의해 전체 문제를 $O(N^2)$에 해결할 수 있다. 이것도 자식 노드들의 결과를 합치는 시간복잡도는 $O({k_n}^p)$일 때 전체 문제를 $O(N^p)$에 해결할 수 있다고 일반화할 수 있다.     References  cubelover의 블로그 - Tree Optimization  ","categories": ["Algorithm"],
        "tags": ["Algorithm-Hard","DP","Tree"],
        "url": "/cs-blog/algorithm/Tree-DP-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84-%EB%B6%84%EC%84%9D/",
        "teaser": null
      },{
        "title": "Jekyll Github 블로그에 Latex 수식 사용",
        "excerpt":"이 글에서는 Mathjax를 이용해 Jekyll 블로그에 LaTex 문법을 이용한 수식을 넣는 법을 알아본다.   마크다운 엔진 변경   _config.yml에서 # Conversion으로 시작되는 부분을 다음과 같이 바꾼다. Minimal Mistakes 등 일부 템플릿에서는 기본으로 적용되어 있다.   # Conversion markdown: kramdown highlighter: rouge lsi: false excerpt_separator: \"\\n\\n\" incremental: false   모든 문서에 적용할 경우   _includes/head.html 맨 끝에 아래 내용을 붙여넣으면 끝이다.   &lt;script type=\"text/x-mathjax-config\"&gt;   MathJax.Hub.Config({       TeX: {         equationNumbers: {           autoNumber: \"AMS\"         }       },       tex2jax: {       inlineMath: [ ['$', '$'] ],       displayMath: [ ['$$', '$$'], ['\\\\[', '\\\\]'] ],       processEscapes: true,     }   }); &lt;/script&gt; &lt;script   type=\"text/javascript\"   async   src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\" &gt;&lt;/script&gt;   특정 문서에만 적용할 경우   mathjax_support.html 생성   _include 디렉토리에 mathjax_support.html를 생성하고 위 섹션에 있는 코드를 그대로 입력한다.   _layouts/default.html 파일 수정   &lt;head&gt;에 아래 코드를 추가한다.   {% if page.use_math %}   {% include mathjax_support.html %} {% endif %}   YAML front-matter 설정   LaTeX 문법을 사용할 포스트의 front-matter에 use_math: true를 적용   --- Title: 2025-03-07-Jekyll-Github-블로그에-LaTeX-수식-사용 categories:   - Others tags:   - Web   - Blog   - Jekyll toc: true use_math: true ---   MathJax 수식 예시   인라인 수식   오일러 공식: $e^{ix} = \\cos(x) + i\\sin(x)$   오일러 공식: $e^{ix} = \\cos(x) + i\\sin(x)$   블록 수식   $$ K(a,b) = \\int \\mathcal{D}x(t) \\exp(2\\pi i S[x]/\\hbar) $$   \\[K(a,b) = \\int \\mathcal{D}x(t) \\exp(2\\pi i S[x]/\\hbar)\\]    References     Jekyll Github 블로그에 MathJax로 수학식 표시하기   MathJax, Jekyll and github pages  ","categories": ["Others"],
        "tags": ["Web","Blog","Jekyll"],
        "url": "/cs-blog/others/Jekyll-Github-%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%97%90-LaTeX-%EC%88%98%EC%8B%9D-%EC%82%AC%EC%9A%A9/",
        "teaser": null
      },{
        "title": "벡터로 두 선분의 교점 구하기",
        "excerpt":"애드혹과 케이스 워크 노가다를 통한 선분 교차 판정은 좀 더럽다. 벡터를 사용해서 케이스를 좀 더 깔끔하게 분류해 선분의 교점을 구해보자.      이 글에서는 편의상 원점과 점 $A$를 잇는 벡터 $\\overrightarrow{OA}$를 $\\overrightarrow{A}$로 표현한다.   요약   원리는 필요 없고 알고리즘만 갖다 쓸 거라면 이걸 그대로 구현하면 된다. 맨 아래에 실제로 작동하는 코드도 있다.      입력 - 두 선분 $\\overline{P_0 P_1}$과 $\\overline{Q_0 Q_1}$   출력 - 두 선분의 교점이 있으면 그 교점을, 두 선분이 한 선분으로 겹치면 그 선분을 반환하며, 두 선분이 만나지 않으면 만나지 않는다고 판단한다.      $u \\leftarrow (\\overrightarrow{P_0 P_1} \\times \\overrightarrow{Q_0 Q_1})$   $u \\ne 0$이라면,            $s \\leftarrow (\\overrightarrow{P_0 Q_0} \\times \\overrightarrow{Q_0 Q_1}) / u \\qquad t \\leftarrow (\\overrightarrow{P_0 Q_0} \\times \\overrightarrow{P_0 P_1}) / u$       $0 \\le s \\le 1$이고 $0 \\le t \\le 1$이면 두 선분은 $\\overrightarrow{OP_0} + s\\overrightarrow{P_0P_1}$에서 교차한다. 그렇지 않으면 교점이 없다.           그렇지 않다면,            $\\overrightarrow{P_0 Q_0} \\times \\overrightarrow{Q_0 Q_1} = 0$, $\\overrightarrow{P_0 Q_0} \\times \\overrightarrow{P_0 P_1} = 0$ 중 하나라도 거짓이면 교점이 없다.       $A_0, \\ A_1 \\leftarrow \\min(P_0, \\ P_1), \\ \\max(P_0, \\ P_1) \\ B_0, \\ B_1 \\leftarrow \\min(Q_0, \\ Q_1), \\ \\max(Q_0, \\ Q_1)$       $L \\leftarrow \\max(A_0, \\ B_0) \\ R \\leftarrow \\min(A_1, \\ B_1)$       $L &lt; R$이면 선분 $LR$에서 겹치고, $L = R$이면 $L$이 교점이고, $L &gt; R$이면 교점이 없다. 이 대소비교는 좌표를 튜플로 두고 통째로 비교하는 것이다.           배경 지식   혹시 벡터에 대해 잘 모르는 상황이라면 이 글을 읽고 오는 것을 추천한다. 고등학교 기하 수준의 배경 지식이 있다면 굳이 안 봐도 되긴 하는데, 선분 교차 판정뿐만 아니라 계산 기하 분야에서 자주 등장하는 알고리즘을 종합적으로 설명하고 있어서 한 번 보면 좋다.   두 벡터를 곱하는 방법 중 하나로 외적(cross product)가 있다. 두 평면벡터의 외적은 그냥 수 하나가 나오고, 다음과 같이 정의된다.   \\[(a_x, a_y) \\times (b_x, b_y) = a_x b_y - a_y b_x\\]  외적의 성질은 다음과 같다.      벡터의 덧셈에 대해 결합법칙과 분배법칙을 만족한다.   외적하는 두 벡터를 교환하면 부호가 반대가 된다. $(\\vec{a} \\times \\vec{b} = - \\vec{b} \\times \\vec{a})$   평행한 두 벡터를 외적하면 $0$이 된다.            두 벡터의 외적이 $0$이 아니면 두 벡터는 평행하지 않다.       같은 벡터를 외적하면 $0$이 된다. $(\\vec{a} \\times \\vec{a} = 0)$.           한편, 두 점 $A$와 $B$를 양 끝점으로 하는 선분 위의 임의의 점 $X$는 다음과 같이 표현할 수 있다.   \\[\\overrightarrow{X} = \\overrightarrow{A} + s\\overrightarrow{AB} \\quad (0 \\le s \\le 1)\\]  풀어서 설명하면, 원점에서 점 $X$까지 가려면 일단 점 $A$까지 간 다음, 선분 $\\overline{AB}$을 따라 이동하면 된다는 것이다. 선분은 점의 집합이기 때문에, 다르게 말하면 저 식이 선분 자체를 벡터로 표현한 것이라고 볼 수도 있다.   알고리즘 구성   위 그림과 같이 두 선분 $\\overline{P_0 P_1}$과 $\\overline{Q_0 Q_1}$이 주어졌을 때 그 교점 $R$이 존재하는지, 존재한다면 어떤 점인지 구할 방법을 생각해보자. 이는 벡터 $\\overrightarrow{R}$이 만족하는 방정식을 써서, 그 식을 만족하는 변수가 존재하는지 확인하고 존재한다면 그 값을 구하는 것으로 수행할 수 있다.     교점 $R$이 존재한다면 다음 두 식을 동시에 만족시키는 실수 $s$와 $t$가 존재한다.   \\[\\begin{aligned} \\overrightarrow{P_0 R} &amp;= s \\overrightarrow{P_0 P_1} &amp;\\quad (0 \\le s \\le 1) \\\\ \\overrightarrow{P_0 R} &amp;= \\overrightarrow{P_0 Q_0} + t \\overrightarrow{Q_0 Q_1} &amp;\\quad (0 \\le t \\le 1) \\\\ \\end{aligned}\\]  식을 정리하면 다음과 같다.   \\[s \\overrightarrow{P_0 P_1} = \\overrightarrow{P_0 Q_0} + t \\overrightarrow{Q_0 Q_1} \\quad (0 \\le s, \\; t \\le 1)\\]  여기서 외적의 결합법칙과 같은 벡터를 외적하면 0이 된다는 사실을 이용하면 $s$와 $t$ 중 하나의 변수를 없앨 수 있다. 양변에 $\\overrightarrow{Q_0 Q_1}$을 외적하면 $t$가 없어지고 다음 식이 나온다.   \\[s (\\overrightarrow{P_0 P_1} \\times \\overrightarrow{Q_0 Q_1}) = (\\overrightarrow{P_0 Q_0} \\times \\overrightarrow{Q_0 Q_1})\\]  $\\overrightarrow{Q_0 Q_1}$ 대신 $\\overrightarrow{P_0 P_1}$을 외적하면 $t$만에 대한 식도 얻을 수 있다.   \\[0 = (\\overrightarrow{P_0 Q_0} \\times \\overrightarrow{P_0 P_1}) + t (\\overrightarrow{Q_0 Q_1} \\times \\overrightarrow{P_0 P_1})\\]  \\[-t (\\overrightarrow{Q_0 Q_1} \\times \\overrightarrow{P_0 P_1}) = t (\\overrightarrow{P_0 P_1} \\times \\overrightarrow{Q_0 Q_1}) = (\\overrightarrow{P_0 Q_0} \\times \\overrightarrow{P_0 P_1})\\]  만약 $\\overrightarrow{P_0 P_1} \\times \\overrightarrow{Q_0 Q_1} \\neq 0$이라면 $s$와 $t$를 바로 구할 수 있다. 여기서부터 $\\overrightarrow{P_0 P_1} \\times \\overrightarrow{Q_0 Q_1} \\neq 0$인 경우, $\\overrightarrow{P_0 P_1} \\times \\overrightarrow{Q_0 Q_1} = 0$인 경우로 케이스를 나눠서 풀어보자.   $\\overrightarrow{P_0 P_1} \\times \\overrightarrow{Q_0 Q_1} \\neq 0$인 경우   $\\overrightarrow{P_0 P_1} \\times \\overrightarrow{Q_0 Q_1} \\neq 0$인 경우는 두 선분 $\\overline{P_0 P_1}$과 $\\overline{Q_0 Q_1}$이 둘 다 길이가 $0$이 아니고 평행하지 않은 경우다. 이 경우엔 앞서 나온 식으로 $s$와 $t$를 바로 계산할 수 있습니다.   \\[s = \\frac{   \\overrightarrow{P_0 Q_0} \\times \\overrightarrow{Q_0 Q_1} } {     \\overrightarrow{P_0 P_1} \\times \\overrightarrow{Q_0 Q_1} } \\qquad  t = \\frac{   \\overrightarrow{P_0 Q_0} \\times \\overrightarrow{P_0 P_1} } {   \\overrightarrow{P_0 P_1} \\times \\overrightarrow{Q_0 Q_1} }\\]  $0 \\leq s, \\; t \\leq 1$이면 교점이 존재하는 것이고, 그렇지 않으면 교점이 없다. 교점의 좌표 $R$은 $\\overrightarrow{R} = \\overrightarrow{P_0} + s\\overrightarrow{P_0 P_1}$로 구할 수 있다.   그 외의 경우   $\\overrightarrow{P_0 P_1} \\times \\overrightarrow{Q_0 Q_1} = 0$인 경우는 두 선분이 평행하거나 길이가 $0$인 경우다. 이 경우엔 두 선분이 겹치는지, 겹치지 않는지를 판단해야 한다.   일단, 네 점이 모두 한 직선 위에 있는지 판단해야 한다. 이는 네 점 $P_0$, $P_1$, $Q_0$, $Q_1$중 세 점을 고르는 모든 경우에 대해 외적이 $0$인지 보면 된다. 즉,   \\[\\begin{aligned} \\overrightarrow{P_0 P_1} \\times \\overrightarrow{P_1 Q_0} &amp;= 0 \\\\ \\overrightarrow{P_0 P_1} \\times \\overrightarrow{P_1 Q_1} &amp;= 0 \\\\ \\overrightarrow{Q_0 Q_1} \\times \\overrightarrow{Q_1 P_0} &amp;= 0 \\\\ \\overrightarrow{Q_0 Q_1} \\times \\overrightarrow{Q_1 P_1} &amp;= 0 \\\\ \\end{aligned}\\]  이 네 등식이 모두 성립하는 지 보면 된다.   위 네 식 중 하나라도 성립하지 않으면 네 점이 한 직선 위에 있지 않은 것인데, 두 선분이 평행하지 않은 경우는 앞에서 이미 걸렀으므로 이때는 반드시 두 선분이 평행하고 만나지 않는 경우다. 따라서 이 때는 교점이 존재하지 않는다.   마지막으로 네 점이 한 직선 위에 있는 경우만 남았다.     $A_0 = \\min(P_0, P_1)$, $A_1 = \\max(P_0, P_1)$, $B_0 = \\min(Q_0, Q_1)$, $B_1 = \\max(Q_0, Q_1)$로 두자.. 이때 점의 비교 기준은 우선 $x$좌표가 작은 것이 더 작은 점이고, $x$좌표가 같다면 $y$좌표가 작은 것이 더 작은 점이다. 이렇게 하면 $\\overrightarrow{A_0 A_1}$과 $\\overrightarrow{B_0 B_1}$의 방향이 같아진다.     그런 다음, $L = \\max(A_0, B_0)$, $R = \\min(A_1, B_1)$이라고 하자. $L \\leq R$이면 두 선분이 겹치는 것이고, $L = R$이면 교점이 $L$이고, $L &gt; R$이면 교점이 없다.   오버플로 주의   내부 계산을 정수형 또는 분수로만 진행한다면 오버플로가 좀 많이 날 수 있다. 점의 좌표 범위가 $10^9$ 이내라면, $s$와 $t$의 분자는 최대 $10^{18}$, 교점의 좌표는 여기에 벡터를 다시 곱하므로 분자가 최대 $10^{27}$까지 늘어난다. 최종 답안이 정확한 분수 형태일 필요가 없다면 적당한 타이밍에 부동소수점으로 바꿔주자. 최종 답안도 분수 형태로 만들고 싶다면 입력값으로 주어지는 좌표의 세제곱까지 처리할 수 있어야 한다. 예를 들어, 입력값의 범위가 i32라면 마지막에는 i128로 계산해야 한다.   이런 게 귀찮으면 파이썬 등 BigInt를 지원하는 언어를 쓰자.   구현   using namespace std; typedef long long ll; typedef long double ld; typedef pair&lt;ll, ll&gt; pll; typedef pair&lt;ld, ld&gt; pld;   ll cross(pll a, pll b) {     return a.first * b.second - a.second * b.first; }  pll sub(pll a, pll b) {     return {a.first - b.first, a.second - b.second}; }  // {0, {0, 0}}: no intersection // {1, {x, y}}: intersection at (x, y) // {2, {0, 0}}: two segments are overlapped (infinite intersections) pair&lt;int, pld&gt; intersect(pll p0, pll p1, pll q0, pll q1) {     pll u = sub(p1, p0);     pll v = sub(q1, q0);     ll det = cross(u, v);     if (det &lt; 0) {         p0.swap(p1);         u.first *= -1;         u.second *= -1;         det *= -1;     }     if (det != 0) {         pll w = sub(q0, p0);         ll cross_wu = cross(w, u);         ll cross_wv = cross(w, v);         if (cross_wu &lt; 0 || cross_wu &gt; det || cross_wv &lt; 0 || cross_wv &gt; det) {             return {0, {0, 0}};         }         ld s = (ld)cross_wv / det;         ld t = (ld)cross_wu / det;         return {1, {p0.first + u.first * s, p0.second + u.second * s}};     } else {         if (cross(sub(q0, p0), u) != 0 || cross(sub(q0, p1), u) != 0 || cross(sub(p0, q0), v) != 0 || cross(sub(p0, q1), v) != 0) {             return {0, {0, 0}};         }         pll a0 = min(p0, p1);         pll a1 = max(p0, p1);         pll b0 = min(q0, q1);         pll b1 = max(q0, q1);         pll l = max(a0, b0);         pll r = min(a1, b1);         if (l &lt; r) {             return {2, {0, 0}};         } else if (l == r) {             return {1, {(ld)l.first, (ld)l.second}};         }         return {0, {0, 0}};     } }  ","categories": ["Algorithm"],
        "tags": ["Algorithm-Normal","Geometry"],
        "url": "/cs-blog/algorithm/%EB%B2%A1%ED%84%B0%EB%A1%9C-%EB%91%90-%EC%84%A0%EB%B6%84%EC%9D%98-%EA%B5%90%EC%A0%90-%EA%B5%AC%ED%95%98%EA%B8%B0/",
        "teaser": null
      }]
