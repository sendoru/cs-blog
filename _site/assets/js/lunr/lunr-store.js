var store = [{
        "title": "Writing The First Post",
        "excerpt":"              Hello, world!는 언제나 국룰이다.   // cpp #include &lt;iostream&gt; int main() {     std::cout &lt;&lt; \"Hello, world!\" &lt;&lt; std::endl;     return 0; }   # python print(\"Hello, world!\")   // Rust use std::io; fn main() {     println!(\"Hello, world!\"); }   console.log(\"Hello, world!\")   To-Do List         ✅ 블로그에 글 하나 올리기       ✅ 블로그 메인 화면 및 사이드바 등에 개인정보 채워두기 (닉네임, 깃헙 링크 등등)       ⬜ 제대로 된 자기소개 페이지 하나 만들기 &lt;- 쓸 거 없어서 못 만드는 중 ㄱ      ✅ 블로그 맨 위에 메뉴 바 만들기       ✅ 블로그 포스트 검색 기능 만들기       ✅ 폰트 및 레이아웃 조절하기. 아직 할 게 좀 남았는데 글 하나 더 써서 기록해둬야겠다.      ✅ 태그 및 기능 추가하기       ❔ 블로그 포스트 연도별 / 카테고리 별 뷰 만들기 &lt;- 반 정도 함       ⬜ 블로그에 HTML로 포스트 올리기 생각보다 구리다. 그냥 MD에 임베드해서 쓰자.       ⬜ Javascript 관련 기능 어떻게 쓰는지 알아보기 나중에 할래   Tips &amp; Troubleshooting           Mardown 파일에 포스트 제목을 따로 쓸 필요는 없다. 굳이 쓰면 이렇게 제목이 두 번 표시된다.                    이미지에 테두리 넣는 법도 배웠다?              Markdown 스타일 List       Markdown에서 1. ... &lt;br&gt; 2. ... &lt;br&gt; ...같은 형태로 글을 쓰면 저절로 ordered list가 된다. ordered list 안의 (plain text를 포함한) 컴포넌트를 작성할 때 들여쓰기를 안 해주면 컴포넌트가 리스트 밖으로 빠져나온다던가 리스트 번호가 1부터 다시 시작한다던가 하는 안 좋은 일이 일어난다. HTML의 &lt;ol&gt; + &lt;li&gt; 등의 태그에서는 스코프가 명확히 정해져 있어서 이런 걸 쓰면 크게 신경 쓸 필요는 없는 일이긴 하다.                     대충 이렇게 된다.              LaTeX 수식       LaTeX로 수식을 써보자.   \\[e^{i \\theta} = \\cos \\theta + i \\sin \\theta\\]      그냥은 안 된다. 다음 코드를 HTML의 &lt;head&gt;에 추가하면 된다.       &lt;head&gt;      &lt;script type=\"text/x-mathjax-config\"&gt;       MathJax.Hub.Config({       tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}       });       &lt;/script&gt;       &lt;script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async&gt;&lt;/script&gt;  &lt;/head&gt;          Markdown으로 작성 중인 경우에는 &lt;head&gt; &lt;/head&gt; 문서 맨 위에 새로 만들어주고 그 안에 저걸 끼워넣으면 된다. 그런데 markdown에서 이렇게 하면 VSCode의 Markdown Preview 확장 프로그램이 맛이 가기 때문에 작성 내용이 어떻게 표시되는지 보고 싶다면 웹 브라우저에서 확인해야 한다.            레이아웃 변경       지금 레이아웃에서 마음에 안 드는 게 몇 가지 있다.                    일반적인 PC 환경인 가로로 길쭉한 화면 상태에서, 글씨가 쓸데없이 커져서 한 화면에 표시되는 정보량이 너무 적어진다. 화면의 가로 길이가 너무 짧다는 생각도 드는데 이것도 폰트 영향일 수도 있어서 폰트부터 고쳐 본 다음에 다시 확인해야 될 것 같다.                   이 정도면 좋을텐데         반응형 UI의 폰트 크기 조절은 _sass/minimal-mistakes/_reset.scss에서 맨 위에 보이는 html 블럭 내의 값들을 바꿔 주면 된다. 가로 폭 조절은 _sass/minimal-mistakes/_variables.scss에서 breakpoints주석 아래에 있는 걸 고쳐주면 된다.            태그 및 카테고리 지정       Markdown 파일 맨 앞에 이렇게 생긴 걸 추가하면 된다.       ---  title: \"Writing The First Post\"  categories:      - Others  tags:      - html      - css      - markup  ---           카테고리를 추가하거나 변경하면 포스트 주소가 바뀐다. 카테고리를 지정하지 않았을 때 주소가 http://sendoru.github.io/cs-blog/writing-the-first-post/였다면, 카테고리를 Others로 바꾼 후에는 http://sendoru.github.io/cs-blog/others/writing-the-first-post/가 된다.       위 문단에서 첫 번째 링크는 접속이 안 되어야 할 것 같은데 캐싱된 게 있는지 예전 페이지로 접속이 된다. 별 상관은 없을 듯            &lt;div&gt; 또는 그 이외의 컨테이너 가운데 정렬        &lt;figure&gt;      &lt;img src=\"/cs-blog/assets/images/writing-the-first-post/image_4.png\" alt=\"\"&gt;      &lt;figcaption&gt; 이 정도면 좋을텐데 &lt;/figcaption&gt;  &lt;/figure&gt;           이렇게 이미지를 넣을 때, 이미지 사이즈를 80%로 줄이고 가운데 정렬로 만드려면  style=\"width: 80%; margin: auto;\" 스타일 속성을 figure에 넣어줘야 한다.       ","categories": ["Others"],
        "tags": ["html","css","markup"],
        "url": "/cs-blog/others/writing-the-first-post/",
        "teaser": null
      },{
        "title": "Writing HTML Post",
        "excerpt":"       Hello, world!                   ","categories": ["Others"],
        "tags": ["html","css"],
        "url": "/cs-blog/others/writing-html-post/",
        "teaser": null
      },{
        "title": "레이아웃 수정 To-Do List",
        "excerpt":"  문제 해결           포스트 페이지 하단의 YOU MAY ALSO ENJOY                     브라우저의 width가 medium일 때 문제가 발생한다.       대충 고쳤다. _sass/minimal-mistakes/_page.scss에서, .page__related에 아래 있는 저걸 추가하면 된다.        @include breakpoint($medium) {      width: 100%;  }                상단바 메뉴                     엄밀히 말하면 문제는 아닌 것 같지만, 메뉴 전체를 보여줄 수 없을 정도로 브라우저 width가 작다면 그냥 오른쪽 위 더보기 메뉴에 모든 메뉴를 몰아넣을 수 있으면 좋을 것 같다. 솔직히 몬가 좀 불편하다.       기능 추가   포스트 기본 스플래시 이미지 / 미리보기 사진 추가   블로그 배너 추가   포스트 목차 추가  ","categories": ["Others"],
        "tags": ["html","css"],
        "url": "/cs-blog/others/%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83-%EC%88%98%EC%A0%95-to-do-list/",
        "teaser": null
      },{
        "title": "Ubuntu Destop + Nvidia Gpu 환경에서 듀얼 모니터 설정",
        "excerpt":"  나는 좀 특이한 구성으로 듀얼 모니터 환경을 세팅해 놨다. 왼쪽에는 1920*1080 해상도의 서브 모니터를 90도 회전시킨 다음 화면 맨 위쪽까지 쳐다보는 게 불편해서 위아래 일부를 잘라놓은 상태로 1080*1440 해상도로 사용하고 있고, 오른쪽에는 2560*1440 해상도의 메인 모니터를 그나마 평범하게 설치해서 사용하고 있다.   NVIDIA X Server를 잘 만져줘서 설정이 제대로 됐다고 생각하고 대충 잘 쓰고 있다가 재부팅을 해 보니 문제가 발생했다. 로그온 화면에서 메인 모니터가 왼쪽 모니터로 설정이 돼 있는지 왼쪽 모니터에 반대 방향으로 90도 돌아간 로그인화면이 떠 있고, 로그인을 하고 나니 메인 모니터는 제대로 잡혔지만 서브 모니터가 1080*1920 사이즈로 화면을 꽉 채우고 있었다.   나중에 Ubuntu를 재설치하거나 다른 PC에 깔 때 삽질하지 않기 위해서 일단 써 둔다.   일단 GPU 드라이버는 설치됐다고 가정하고 글을 쓰겠다. 설치가 안 되어 있다면 이런 글을 참고해서 설치해 주도록 하자.           NVIDIA X Server로 설정 변경       우선 터미널에 sudo nvidia-settings를 쳐서 X Server를 실행시킨다. 듀얼 모니터의 해상도나 모니터 배치 같은 설정은 왼쪽 메뉴에서 X Server Display Configuration을 선택하면 볼 수 있다.       메인 모니터 설정은, 위쪽에서 메인 모니터로 설정할 모니터를 선택하고 Make this the primary display for the X screen을 체크해주면 된다. 모니터를 회전시켜서 사용하는 경우, Orientation의 설정을 바꿔주면 된다.       나처럼 모니터의 일부만 사용할 경우 Advanced… 뷰의 ViewPortIn, ViewPortOut, Panning 옵션을 사용해야 된다.                     ViewPortIn과 Panning에는 모두 출력할 화면의 해상도를 적는다. ViewPortOut은 XsizexYsize+Xoffset+Yoffset 형식이다. 모니터를 회전시키지 않은 상태라면 XsizexYsize 부분에는 ViewPortIn과 Panning에 적은 값을 그대로 적으면 되고, 회전시켰다면 Xsize와 Ysize의 순서를 바꿔서 적으면 된다. Xoffset과 Yoffset은 화면의 표시 위치를 결정하는 변수이다. 잘 조절해 가면서 자신에게 맞는 값을 설정하면 된다.            재부팅 / 다시 로그인 했을 때도 설정 유지       터미널에 sudo nvidia-settings를 쳐서 xorg.conf 파일을 생성한다. 이후 xorg.conf 파일에서 “Device”로 시작하는 블럭을 찾은 후, 아래 내용을 블럭 끝에 붙여넣는다.        Option \"RegistryDwords\" \"PowerMizerEnable=0x1; PerfLevelSrc=0x3322\"           (출처: https://askubuntu.com/questions/379483/nvidia-x-server-settings-lost-on-every-reboot)            로그인 전 화면에도 설정 적용       아래 명령어를 터미널에 입력하면 된다. gdm은 그래픽 로그인 화면을 관리하는 특수한 유저라고 생각하면 된다.        sudo cp ~/.config/monitors.xml ~gdm/.config/monitors.xml  sudo chown gdm:gdm ~gdm/.config/monitors.xml           왜인지는 모르겠지만 이 방법으로 해결했다는 다른 글들을 보면 한 번에 되지 않고 재부팅을 몇 번씩 해가면서 여러 번 시도해야 했다는 얘기가 있다.       (출처: https://askubuntu.com/questions/1043337/is-there-to-make-the-login-screen-appear-on-the-external-display-in-18-04)      ","categories": ["Others"],
        "tags": ["ubuntu","environment-setup"],
        "url": "/cs-blog/others/Ubuntu-Destop-+-NVIDIA-GPU-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-%EB%93%80%EC%96%BC-%EB%AA%A8%EB%8B%88%ED%84%B0-%EC%84%A4%EC%A0%95/",
        "teaser": null
      },{
        "title": "PostgreSQL Basics",
        "excerpt":"대충 아래 링크 강의에 나오는 것 정도를 정리했다.   https://www.freecodecamp.org/learn/relational-database/learn-relational-databases-by-building-a-mario-database/build-a-mario-database   DB 접속: psql --username=$USERNAME --dbname=$DBNAME (bash에서)   psql 명령어   앞에 \\ 붙어있는 명령어들은 psql에서 사용하는 명령어들이다.     DB list 확인: \\l   특정 DB 접속: \\c &lt;DB_NAME&gt;   특정 DB에 접속한 상태에서 table list 확인: \\d,   특정 table의 schema 확인: \\d &lt;TABLE_NAME&gt;   SQL 명령어   SQL 쿼리 명령어들 (CREATE, SELECT, INSERT, UPDATE, DELETE 등)은 뒤에 세미콜론을 붙여야 한다.   CREATE      DB 생성:      CREATE DATABASE &lt;db_name&gt;;           Table 생성:      CREATE TABLE &lt;table_name&gt; (column1 datatype [constraint], column2 datatype [constraint], ...);           DROP      Table 삭제:      DROP TABLE &lt;table_name&gt;;           DB 삭제:      DROP DATABASE &lt;db_name&gt;;           INSERT      Tuple 추가:      INSERT INTO &lt;table_name&gt; (column1, column2, ...) VALUES (value1, value2, ...);          한 번에 여러 tuple도 추가할 수 있다.      INSERT INTO &lt;table_name&gt; (column1, column2, ...) VALUES   (value1, value2, ...),    (value1, value2, ...),   ...;           DELETE      Tuple 삭제:      DELETE FROM &lt;table_name&gt; WHERE &lt;condition&gt;;                 Equal은 ==가 아니라 =이다.           ALTER      Table 이름 변경:      ALTER TABLE &lt;table_name&gt; RENAME TO &lt;new_table_name&gt;;           DB 이름 변경:      ALTER DATABASE &lt;db_name&gt; RENAME TO &lt;new_db_name&gt;;           Table scheme 변경:            Column 추가:            ALTER TABLE &lt;table_name&gt; ADD &lt;column_name&gt; &lt;data_type&gt; [&lt;constraint_name&gt;];                             외래 키로 추가               ALTER TABLE &lt;table_name&gt;   ADD COLUMN &lt;column_name&gt; &lt;data_type&gt;   REFERENCES &lt;another_table_name&gt;(&lt;another_column_name&gt;);                                               Column 삭제:            ALTER TABLE &lt;table_name&gt; DROP &lt;column_name&gt;;                       Column 이름 변경:            ALTER TABLE &lt;table_name&gt; RENAME COLUMN &lt;column_name&gt; TO &lt;new_column_name&gt;;                       Column 타입 변경:            ALTER TABLE &lt;table_name&gt; ALTER COLUMN &lt;column_name&gt; TYPE &lt;new_data_type&gt;;                           Column에 constraint 추가:             NOT NULL constraint 추가:            ALTER TABLE &lt;table_name&gt; ALTER COLUMN &lt;column_name&gt; SET NOT NULL;                       UNIQUE constraint 추가:            ALTER TABLE &lt;table_name&gt; ADD CONSTRAINT &lt;constraint_name&gt; UNIQUE (&lt;column_name&gt;);                           특정 Column을 기본 키로 설정:      ALTER TABLE &lt;table_name&gt; ADD PRIMARY KEY (&lt;column_name&gt;);           특정 Column을 외래 키로 설정:      ALTER TABLE &lt;table_name&gt; ADD FOREIGN KEY (&lt;column_name&gt;) REFERENCES &lt;another_table_name&gt;(&lt;another_column_name&gt;);           Update      Tuple 업데이트:      UPDATE &lt;table_name&gt; SET column1 = value1, column2 = value2, ... WHERE &lt;condition&gt;;           SELECT   SELECT column1, column2, ...     FROM &lt;table_name&gt;     [WHERE &lt;condition&gt;]     [ORDER BY column1, column2, ... [ASC|DESC]]     [LIMIT &lt;number&gt;]     ;  group by, having, join, 집계 함수, 중첩 쿼리 같은 것 까지 여기서 설명하긴 너무 길다. 다른 글에서 다루려면 join에 포스트 하나, 집계 함수에 포스트 하나, 중첩 쿼리에 포스트 하나 정도 될 것 같긴 한데…   자료형      int: 다 알고 있을 그거   numeric(precision, scale): 고정소수점 숫자. precision은 전체 자릿수, scale은 소수점 이하 자릿수   serial: auto-incrementing integer   varchar(n): 최대 n글자의 가변 길이 문자열   text: 길이 제한 없는 가변 길이 문자열            문자열은 ‘‘로 감싸야 한다. ““는 table, column 이름 같은 데 사용된다.           boolean: true 또는 false   date: 날짜. YYYY-MM-DD 형식 문자열 직접 입력 가능  ","categories": ["Others"],
        "tags": ["Database","SQL"],
        "url": "/cs-blog/others/PostgreSQL-Basics/",
        "teaser": null
      },{
        "title": "Node.js Build + Test",
        "excerpt":"빌드 환경  HW     Ryzen 5 5600X   DDR4 48GB   text   Native     Ubuntu 24.04   Python 3.12.4   Make 4.3   GCC 13.2.0   Docker 가상환경   text 여기에서 Node.js를 위한 dev container 설정 방법을 알려주고 있다.  docker pull nodejs/devcontainer:nightly docker run -it nodejs/devcontainer:nightly /bin/bash      Ubuntu 22.04   Python 3.10.6   Make 4.3   GCC 11.3.0   빌드 결과   time make -j10   빌드 자체에서 에러는 안 떴다. 아래에 있는 빌드 시간은 Docker에서 돌렸을 때의 시간인데, native로 돌렸을 때도 아마 비슷하게 나왔던 것 같다.  real    20m18.848s user    180m33.354s sys     16m22.906s   테스트 결과  Native   make test-only   Test case 2개에서 에러가 터졌다.   === release test-net-socket-connect-without-cb ===                             Path: parallel/test-net-socket-connect-without-cb node:events:498       throw er; // Unhandled 'error' event       ^  Error: getaddrinfo ENOTFOUND localhost     at GetAddrInfoReqWrap.onlookup [as oncomplete] (node:dns:109:26) Emitted 'error' event on Socket instance at:     at emitErrorNT (node:internal/streams/destroy:170:8)     at emitErrorCloseNT (node:internal/streams/destroy:129:3)     at process.processTicksAndRejections (node:internal/process/task_queues:82:21) {   errno: -3007,   code: 'ENOTFOUND',   syscall: 'getaddrinfo',   hostname: 'localhost' }  Node.js v23.0.0-pre Command: out/Release/node /home/sendol/programming-projects/node/test/parallel/test-net-socket-connect-without-cb.js   === release test-tcp-wrap-listen ===                                           Path: parallel/test-tcp-wrap-listen (node:377826) internal/test/binding: These APIs are for internal testing only. Do not use them. (Use `node --trace-warnings ...` to show where the warning was created) node:events:498       throw er; // Unhandled 'error' event       ^  Error: getaddrinfo ENOTFOUND localhost     at GetAddrInfoReqWrap.onlookup [as oncomplete] (node:dns:109:26) Emitted 'error' event on Socket instance at:     at emitErrorNT (node:internal/streams/destroy:170:8)     at emitErrorCloseNT (node:internal/streams/destroy:129:3)     at process.processTicksAndRejections (node:internal/process/task_queues:82:21) {   errno: -3007,   code: 'ENOTFOUND',   syscall: 'getaddrinfo',   hostname: 'localhost' }  Node.js v23.0.0-pre Command: out/Release/node --expose-internals /home/sendol/programming-projects/node/test/parallel/test-tcp-wrap-listen.js   [05:18|% 100|+ 4154|-   2]: Done                                                Failed tests: out/Release/node /home/sendol/programming-projects/node/test/parallel/test-net-socket-connect-without-cb.js out/Release/node --expose-internals /home/sendol/programming-projects/node/test/parallel/test-tcp-wrap-listen.js make[1]: *** [Makefile:312: jstest] 오류 1 make: *** [Makefile:346: test-only] 오류 2   Docker  Docker에서는 모든 test case가 통과했다.   [03:50|% 100|+ 3878|-   0]: Done                                                All tests passed. make tooltest ..... ---------------------------------------------------------------------- Ran 5 tests in 0.002s  OK  real\t5m59.461s user\t10m28.708s sys\t3m12.673s  ","categories": ["Others"],
        "tags": ["Node.js"],
        "url": "/cs-blog/others/Node.js-Build-+-Test/",
        "teaser": null
      },{
        "title": "Node.js net.lookUpAndConnect 버그 수정",
        "excerpt":"일단 저번에 가상환경 밖에서 돌렸을 때 에러가 떴던 테스트의 에러 메세지부터 살펴보자.      node/test/parallel/test-net-socket-connect-without-cb.js   === release test-net-socket-connect-without-cb ===                             Path: parallel/test-net-socket-connect-without-cb node:events:498       throw er; // Unhandled 'error' event       ^  Error: getaddrinfo ENOTFOUND localhost     at GetAddrInfoReqWrap.onlookup [as oncomplete] (node:dns:109:26) Emitted 'error' event on Socket instance at:     at emitErrorNT (node:internal/streams/destroy:170:8)     at emitErrorCloseNT (node:internal/streams/destroy:129:3)     at process.processTicksAndRejections (node:internal/process/task_queues:82:21) {   errno: -3007,   code: 'ENOTFOUND',   syscall: 'getaddrinfo',   hostname: 'localhost' }      node/test/parallel/test-tcp-wrap-listen.js   === release test-tcp-wrap-listen ===                                           Path: parallel/test-tcp-wrap-listen (node:377826) internal/test/binding: These APIs are for internal testing only. Do not use them. (Use `node --trace-warnings ...` to show where the warning was created) node:events:498       throw er; // Unhandled 'error' event       ^  Error: getaddrinfo ENOTFOUND localhost     at GetAddrInfoReqWrap.onlookup [as oncomplete] (node:dns:109:26) Emitted 'error' event on Socket instance at:     at emitErrorNT (node:internal/streams/destroy:170:8)     at emitErrorCloseNT (node:internal/streams/destroy:129:3)     at process.processTicksAndRejections (node:internal/process/task_queues:82:21) {   errno: -3007,   code: 'ENOTFOUND',   syscall: 'getaddrinfo',   hostname: 'localhost' }   localhost에 연결을 시도하고 있는 것 같다. node/test/parallel/test-net-socket-connect-without-cb.js 코드에 로그를 찍어서 client.connect 함수에 뭔 인자가 넘어가는지 한 번 보자.   'use strict'; const common = require('../common');  // This test ensures that socket.connect can be called without callback // which is optional.  const net = require('net');  const server = net.createServer(common.mustCall(function(conn) {   conn.end();   server.close(); })).listen(0, common.mustCall(function() {   const client = new net.Socket();    client.on('connect', common.mustCall(function() {     client.end();   }));    const address = server.address();   if (!common.hasIPv6 &amp;&amp; address.family === 'IPv6') {     // Necessary to pass CI running inside containers.     client.connect(address.port);   } else {     console.log(address);      // added     client.connect(address);   } }));   Output  {address: '::', family: 'IPv6', port: 38065}   뭔가 이상하다. localhost라는 DNS 주소가 아니라 ::라는 IPv6 주소가 넘어가는데… 또 이상한 게 있는데, 아래 코드를 main branch의 node로 실행시킨 후 nc :: 12345 명령어로 서버에 접속하면 접속이 잘 된다.   'use strict';  const net = require('net');  const server = net.createServer((conn) =&gt; {     conn.write(\"Hello World\\n\");     conn.end();     server.close(); }).listen({     host: '::',     port: 12345,     family: 'IPv6' }, function () {     const client = new net.Socket();      client.on('connect', function () {         // send message and close         client.write(\"Hello World\\n\");         client.end();     });로 });   추가로, 테스트 코드의 에러 내용으로 구글링을 해 보니까 /etc/hosts를 수정해 localhost가 :: 주소로 resolve 될 수 있게 하면 된다고 하는데, 그 전에 Node.js에서 굳이 IP 주소가 아니라 DNS 주소로 연결을 시도하는 것 부터가 문제인 것 같아서 일단 놔두기로 했다.   node/lib/net.js 코드에 있는 net.Socket.connect 함수(node/lib/net.js에서는 프로토타입 함수인 Socket.prototype.connect)에 중단점을 열심히 찍어서 디버깅을 해 봤고, 함수의 마지막인 아래 부분 이전에서는 에러가 안 터지는 걸 찾았다.     if (pipe) {     validateString(path, 'options.path');     defaultTriggerAsyncIdScope(       this[async_id_symbol], internalConnect, this, path,     );   } else {     lookupAndConnect(this, options);   }   return this;   또한 node/test/parallel/test-net-socket-connect-without-cb.js 테스트 코드에서는 else 쪽으로 분기가 되고, lookupAndConnect에 전달되는 options 인자가 테스트 코드의 client.connect(address);와 같다는 것도 발견했다. 정확히는 address가 경우에 따라 약간 전처리가 되고 lookupAndConnect에 전달되는데, 지금의 경우에는 그대로 전달된다.   그래서 lookupAndConnect에도 중단점을 계속 찍어가면서 에러가 발생하는 부분을 찾아봤다. 이 부분이었다. 정확히는 lookup 함수에서 에러가 발생한 후 콜백 함수인 emitLookup에 에러 내용이 전달되고, process.nextTick으로 throwing을 하는 것 같다.     defaultTriggerAsyncIdScope(self[async_id_symbol], function() {     lookup(host, dnsopts, function emitLookup(err, ip, addressType) {       self.emit('lookup', err, ip, addressType, host);        // It's possible we were destroyed while looking this up.       // XXX it would be great if we could cancel the promise returned by       // the look up.       if (!self.connecting) return;        if (err) {         // net.createConnection() creates a net.Socket object and immediately         // calls net.Socket.connect() on it (that's us). There are no event         // listeners registered yet so defer the error event to the next tick.         process.nextTick(connectErrorNT, self, err);       } else if (!isIP(ip)) {         err = new ERR_INVALID_IP_ADDRESS(ip);         process.nextTick(connectErrorNT, self, err);       } else if (addressType !== 4 &amp;&amp; addressType !== 6) {         err = new ERR_INVALID_ADDRESS_FAMILY(addressType,                                              options.host,                                              options.port);         process.nextTick(connectErrorNT, self, err);       } else {         self._unrefTimer();         defaultTriggerAsyncIdScope(           self[async_id_symbol],           internalConnect,           self, ip, port, addressType, localAddress, localPort,         );       }     });   });   위의 코드 블럭에서 lookup에 넘어가는 인자들을 보니까 host는 'localhost'였고, dnsopts에는 IP 버전 정보와 DNS resolver 관련 정보가 들어있었다. 앞서 말했듯 DNS 주소인 localhost가 IPv6 주소로 resolve되도록 hosts 파일을 설정하지 않아서 저런 인자가 넘어가면 에러가 나는 건 이상하지 않은데, 애초에 host에 IP 주소 대신 'localhost'가 들어가는 게 이상하다.   다시 lookupAndConnect 함수를 전체적으로 살펴봤다. 그리고 lookupAndConnect에 인자로 넘어간 options의 options.address 값을 함수 내부에서 전혀 이용하지 않는 것을 발견했다. 그 대신 server.address의 리턴값에는 존재하지 않는 값인 options.host를 사용해서 lookup에 전달될 host를 정의하고 있었다.   function lookupAndConnect(self, options) {   const { localAddress, localPort } = options;   const host = options.host || 'localhost';   let { port, autoSelectFamilyAttemptTimeout, autoSelectFamily } = options;    ...  }   이제 이유는 알아냈으니까 host 값으로 options.address 도 사용할 수 있게 만들자. host 값으로 options.host가 사용되는 것을 가정하고 만든 코드도 많을 테니까 위 코드에서 options.host를 options.address로 바꿔버리면 안 될 것이다. 대신 options.host가 존재하지 않을 때만 options.address 값을 host로 이용하고, options.address 값도 없을 때 이전처럼 host를 'localhost'로 만들면 될 것이다.   function lookupAndConnect(self, options) {   const { localAddress, localPort } = options;   let host = options.host;   if (!host) {     host = options.address;   }   if (!host) {     host = 'localhost';   }   let { port, autoSelectFamilyAttemptTimeout, autoSelectFamily } = options;    ...  }   이러고 다시 bulid 후 test를 돌려보니 처음 고치기로 했던 test-net-socket-connect-without-cb 뿐만 아니라 node/test/parallel/test-tcp-wrap-listen.js 까지 고쳐졌고, 새로 발생한 에러는 없어서 모든 test를 통과했다.   이제 GitHub에 Issue랑 PR을 어떻게 올릴 지 좀 알아봐야 될 것 같다.   그나저나 저런 버그가 있으면 server.address()의 리턴 값 형식으로 서버 주소를 알아왔을 때, localhost가 아닌 서버에 접속하면 항상 에러가 터질 텐데… 이게 어떻게 지금까지 남아있지.  ","categories": ["Others"],
        "tags": ["Node.js"],
        "url": "/cs-blog/others/Node.js-net.lookUpAndConnect-%EB%B2%84%EA%B7%B8-%EC%88%98%EC%A0%95/",
        "teaser": null
      },{
        "title": "Node.js + V8",
        "excerpt":"Node.js repo의 ./src 디렉토리에 가 보면, 시스템 콜 사용 같은 저레벨 작업이나 퍼포먼스 향상을 위해 C++로 작성된 코드가 보일 것이다. 그리고 이 코드들을 까 보면 v8 네임스페이스의 뭔가로 가득 차 있어 C++만 잘 한다고 코드를 이해하기가 쉽지 않다. 이 글에서는 V8이 무엇인지, Node.js와 어떤 관계가 있는지, 그리고 Node.js의 C++ 코드를 이해하는데 도움이 되는 V8의 핵심 개념들을 살펴보겠다.   V8이란 무엇인가?   V8은 구글에서 개발한 C++ 기반의 오픈소스 JavaScript 엔진이다. JavaScript 엔진은 JavaScript 코드를 해석하고 실행하는 프로그램이다. V8은 웹 브라우저인 크롬의 핵심 엔진으로 사용되며, Node.js도 V8을 사용하여 JavaScript 코드를 실행한다.   JavaScript 런타임 환경의 일종이라고 하는 Node.js도 자바스크립트를 실행하는 프로그램인데, 런타임 환경과 엔진의 차이는 구체적으로 다음과 같다. JavaScript 엔진은 일종의 인터프리터 또는 컴파일러에 해당된다. ECMAScript 표준에 따라 JavaScript 코드를 해석하고 실행하는 역할을 하지만, 파일 I/O나 네트워크 요청 같은 시스템 레벨의 기능은 제공하지 않는다. 런타임 환경은 이러한 엔진을 포함하며, 바닐라 JavaScript 외에도 브라우저의 DOM API나 Node.js의 fs 모듈 같은 기능을 제공하여 더 넓은 용도로 사용할 수 있게 한다.   V8의 다른 중요한 기능은, C++ 코드와 JavaScript 코드 간의 상호작용을 가능하게 하는 바인딩이다. 이를 통해 C++로 작성된 코드에서 JavaScript 함수를 호출하거나, JavaScript 코드에서 C++ 함수를 호출할 수 있다. Node.js의 C++ 코드는 이러한 바인딩을 통해 V8의 기능을 활용하여 JavaScript 코드와 상호작용한다.   이제 V8의 핵심 개념을 살펴보고, 이를 통해 JavaScript 코드에서 불러올 수 있는 C++ 함수가 어떻게 작성되는지 알아보자.   V8의 핵심 개념   Isolate   v8::Isolate 클래스는 V8에서 작동되는 하나의 JavaScript 실행 환경을 나타낸다. 각 Isolate는 자신만의 메모리 공간을 가지며, 서로 다른 Isolate 간에는 데이터를 공유할 수 없다. 이는 JavaScript 코드가 실행되는 환경을 격리시켜, 서로 다른 Isolate 간에는 데이터 누출이나 충돌이 발생하지 않도록 한다.   Node.js에서는 각 요청이나 연결마다 새로운 Isolate를 생성하여 격리를 유지한다. 이를 통해 하나의 요청이 다른 요청에 영향을 미치지 않도록 보장한다.   Context   v8::Context 클래스는 JavaScript 코드가 실행되는 환경을 나타낸다. Context는 Isolate 내에 생성되며, 여러 개의 Context를 생성하여 각각의 JavaScript 코드를 실행할 수 있다. Context는 JavaScript 코드가 실행되는 환경을 나타내므로, Context를 통해 JavaScript 코드에서 사용할 수 있는 전역 객체나 함수 등을 정의할 수 있다.   V8 JavaScript Value   V8은 JavaScript의 값들을 C++에서 사용할 수 있는 형태로 표현하기 위해 v8::Value 클래스를 사용한다. v8::Value 클래스는 JavaScript의 모든 자료형에 대응되며, 특정한 자료형을 나타내고 싶다면 서브클래스인 v8::String, v8::Number, v8::Object 등을 사용한다. Value의 실제 값을 C++의 타입으로 변환하기 위해서는 Value 객체를 적절한 서브클래스로 캐스팅한 후, .Value() 메소드를 사용한다.   Value handle   JavaScript value는 v8::Value 객체로 표현되며, 이 객체를 다루기 위해 handle이라는 일종의 포인터를 사용한다. v8::Value 객체는 Local, Global, 두 가지 타입의 handle을 가질 수 있다.   Local handle   v8::Local&lt;T&gt; handle은 v8::Value 객체를 가리키는 임시 포인터이다. 특정 스코프 내에서만 유효하며, 스코프를 벗어나면 자동으로 해제된다. 주로 함수 내의 지역 변수로 사용된다.   Local handle이 생성되기 이전에, v8::HandleScope나 v8::EscapableHandleScope 객체가 스택에 존재해야 한다. Local handle은 이 스코프에 추가되며, 스코프와 함께 삭제된다. EscapableHandleScope는 HandleScope와 달리 Local handle을 반환할 수 있으며, 이를 통해 handle을 다른 스코프로 넘길 수 있다.   단, binding 함수 내에서 Local handle을 사용할 때는 이미 함수 밖에 HandleScope가 존재하므로, 다른 스코프를 생성할 필요가 없다.   간단한 JavaScript 코드와 그에 대응되는 C++ 코드를 살펴보자.   function getFoo(obj) {   return obj.foo; }   v8::Local&lt;v8::Value&gt; GetFoo(v8::Local&lt;v8::Context&gt; context,                             v8::Local&lt;v8::Object&gt; obj) {   v8::Isolate* isolate = context-&gt;GetIsolate();   v8::EscapableHandleScope handle_scope(isolate);    // The 'foo_string' handle cannot be returned from this function because   // it is not “escaped” with `.Escape()`.   v8::Local&lt;v8::String&gt; foo_string =       v8::String::NewFromUtf8(isolate, \"foo\").ToLocalChecked();    v8::Local&lt;v8::Value&gt; return_value;   if (obj-&gt;Get(context, foo_string).ToLocal(&amp;return_value)) {     return handle_scope.Escape(return_value);   } else {     // There was a JS exception! Handle it somehow.     return v8::Local&lt;v8::Value&gt;();   } }   Global handle   v8::Global&lt;T&gt; handle은 JavaScript 엔진이 종료되지 않는 한 계속 유지될 수 있는 포인터이다. 전역 변수나 모듈 변수 같이 계속 사용되는 값들에 사용된다.   Global handle에는 strong과 weak 두 가지 타입이 있다. strong handle은 JavaScript 엔진이 종료되지 않는 한 계속 유지되는 반면, weak handle은 다른 값에 의해 참조되지 않으면 자동으로 해제된다.   Exception handling   V8은 C++의 exception을 JavaScript에 직접 bind할 수 없다. 그 대신 Maybe 타입을 사용하거나 TryCatch 객체를 사용하여 JavaScript 코드에서 발생한 예외를 처리할 수 있다.   Maybe, MaybeLocal 타입   V8의 Maybe&lt;T&gt;와 MaybeLocal&lt;T&gt; 타입은 반환값이 있을 수도 있고 없을 수도 있는 함수의 반환값을 나타낸다. std::optional과 비슷한 것이라고 보면 된다. Maybe&lt;T&gt;의 값이 비어 있는 경우 (.IsNothing()이 true인 경우)는 예외가 발생한 것으로 간주할 수 있다. 함수의 반환 타입이 Maybe&lt;T&gt;인 경우, 함수 내부에서 서브클래스인 Just&lt;T&gt;나 Nothing&lt;T&gt;을 반환하여 값을 반환하거나 예외를 처리할 수 있다.   MaybeLocal&lt;T&gt;는 Local handle을 반환하는 함수의 반환 타입으로 사용된다. MaybeLocal&lt;T&gt;는 Maybe&lt;T&gt;와 비슷하게 동작하지만, Local handle을 반환한다는 점이 다르고 메소드 이름에도 차이가 있다.                  Maybe       MaybeLocal                       maybe.IsNothing()       maybe_local.IsEmpty()                 maybe.IsJust()       !maybe_local.IsEmpty()                 maybe.To(&amp;value)       maybe_local.ToLocal(&amp;local)                 maybe.ToChecked()       maybe_local.ToLocalChecked()                 maybe.FromJust()       maybe_local.ToLocalChecked()                 maybe.Check()       –                 v8::Nothing&lt;T&gt;()       v8::MaybeLocal&lt;T&gt;()                 v8::Just&lt;T&gt;(value)       v8::MaybeLocal&lt;T&gt;(value)           TryCatch 객체   Funtion binding   이제 binding funciton을 쓰기 위한 정말 기초적인 것들은 살펴봤다. 이제 실제로 JavaScript 코드에서 불러올 수 있는 C++ 함수를 작성해보자.   JavaScript에 노출되는 C++ 함수는 다음과 같은 형태를 가진다. 아래 함수는 node_util.cc 파일에 정의된 함수로, ArrayBufferView 객체가 주어졌을 때 해당 객체가 버퍼를 가지고 있는지 확인하는 함수이다.   void ArrayBufferViewHasBuffer(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {   CHECK(args[0]-&gt;IsArrayBufferView());   args.GetReturnValue().Set(args[0].As&lt;ArrayBufferView&gt;()-&gt;HasBuffer()); }   (네임스페이스는 using v8;로 설정되어 있다고 가정한다.)   args는 JavaScript 함수에 전달된 전체 인자를 담고 있고, args[i]는 i번째 (0-based) 인자를 나타낸다. args.GetReturnValue()는 함수의 반환값을 설정하는데 사용되며, Set() 메소드를 통해 반환값을 설정한다.   이 함수를 JavaScript에서 사용하려면 다음과 같이 SetMethod, SetMethodNoSideEffect 등의 함수를 이용해 Node.js의 target 객체에 함수를 등록해야 한다.   void Initialize(Local&lt;Object&gt; target,                 Local&lt;Value&gt; unused,                 Local&lt;Context&gt; context,                 void* priv) {   Environment* env = Environment::GetCurrent(context);    SetMethod(context, target, \"getaddrinfo\", GetAddrInfo);   // ... }  NODE_MODULE_CONTEXT_AWARE(NODE_GYP_MODULE_NAME, Initialize);   이제 기존에 존재하는 모듈에 SumNumbers라는 함수를 추가해보자. 이 함수는 배열을 받아 배열의 모든 요소를 더한 값을 반환하며, 배열의 요소가 숫자가 아닌 경우 예외를 발생시킨다.   // This could also return a v8::MaybeLocal&lt;v8::Number&gt;, for example. v8::Maybe&lt;double&gt; SumNumbers(v8::Local&lt;v8::Context&gt; context,                              v8::Local&lt;v8::Array&gt; array_of_integers) {   v8::Isolate* isolate = context-&gt;GetIsolate();   v8::HandleScope handle_scope(isolate);    double sum = 0;    for (uint32_t i = 0; i &lt; array_of_integers-&gt;Length(); i++) {     v8::Local&lt;v8::Value&gt; entry;     if (!array_of_integers-&gt;Get(context, i).ToLocal(&amp;entry)) {       // Oops, we might have hit a getter that throws an exception!       // It's better to not continue return an empty (“nothing”) Maybe.       return v8::Nothing&lt;double&gt;();     }      if (!entry-&gt;IsNumber()) {       // Let's just skip any non-numbers. It would also be reasonable to throw       // an exception here, e.g. using the error system in src/node_errors.h,       // and then to return an empty Maybe again.       continue;     }      // This cast is valid, because we've made sure it's really a number.     v8::Local&lt;v8::Number&gt; entry_as_number = entry.As&lt;v8::Number&gt;();      sum += entry_as_number-&gt;Value();   }    return v8::Just(sum); }  // Function that is exposed to JS: void SumNumbers(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; args) {   // This will crash if the first argument is not an array. Let's assume we   // have performed type checking in a JavaScript wrapper function.   CHECK(args[0]-&gt;IsArray());    double sum;   if (!SumNumbers(args.GetIsolate()-&gt;GetCurrentContext(),                   args[0].As&lt;v8::Array&gt;()).To(&amp;sum)) {     // Exception was thrown     // Nothing to do, we can just return directly to JavaScript.     return;   }    args.GetReturnValue().Set(sum); }   첫 번째 함수는 배열의 합을 구하는 실제 로직이 담겨 있는 함수로, 다른 함수에서의 예외 처리를 위해 Maybe 타입을 반환한다. 두 번째 함수는 JavaScript와 실제로 binding되는 wrapper 함수로, Maybe 타입을 처리하여 JavaScript에 반환한다.   두 번째 함수의 if문 내 조건식이 !SumNumbers(...).To(&amp;sum)인 이유는, SumNumbers 함수가 Maybe 타입을 반환하기 때문이다. To 메소드는 Maybe 타입을 받아서 그 안에 있는 값을 sum에 넣어주는 역할을 한다. 만약 SumNumbers 함수가 Nothing을 반환한다면, To 메소드는 false를 반환하고 sum에는 아무 값도 들어가지 않는다.   이제 이 함수를 Node.js에서 사용할 수 있도록 target 객체에 등록하면 된다.   void Initialize(Local&lt;Object&gt; target,                 Local&lt;Value&gt; unused,                 Local&lt;Context&gt; context,                 void* priv) {   Environment* env = Environment::GetCurrent(context);    /*   / Other functions...   */    SetMethod(context, target, \"sumNumbers\", SumNumbers); }   마지막으로, js 파일에서 이 함수를 사용할 수 있도록 sumNumbers 함수를 등록하면 된다.   const { sumNumbers } = internalBinding(\"MODULE_NAME\");   주의할 점으로, C++ 코드의 주석에도 있지만 SumNumbers 함수로 들어오는 인자가 Array 타입이 아닌 경우에 대한 예외 처리가 없다. 이는 JavaScript 코드에서 미리 타입 체크를 하고 넘겨주는 것이 좋다.   어쩌다 보니 Node.js의 Node.js C++ codebase 공식 문서를 번역해서 libuv 내용 날린 다음에 압축해 놓은 것 같은 글이 됐는데 글이 꽤 길어졌다. 그 와중에 메모리 관리, bootstrap 과정에서의 C++ binding 로딩 등 빠진 내용도 좀 있다. 나중에 시간나면 더 살펴봐야겠다.      이 글의 코드 대부분은 Node.js C++ codebase 공식 문서에서 가져왔다.  ","categories": ["Others"],
        "tags": ["Node.js"],
        "url": "/cs-blog/others/Node.js-+-V8/",
        "teaser": null
      },{
        "title": "Tree DP 시간복잡도 분석",
        "excerpt":"Tree DP를 DFS를 이용해 구현할 때, 실제 시간복잡도는 코드를 보고 대충 생각한 것보다 작은 경우가 많다. 이 글에서는 그런 몇몇 케이스를 다룬다.   자식 노드의 결과를 합칠 때 자식 서브트리 크기에 대한 다항식 시간이 걸릴 경우   보통 Tree DP는 다음과 비슷한 함수를 만들고 루트 노드를 함수 인자로 넘겨 실행하면 풀 수 있다.   void dfs(int node) {     (dp_table[node] 초기화);     for (int next : children[node]) {         dfs(next);     }     (dp_table[next]들의 값을 이용해 dp_table[node] 계산); } dfs(root_node);   노드 갯수가 $N$개인 트리에서 노드 $n$의 자식이 $k_n$개 있고, 이 자식들을 루트로 하는 $k$개의 서브트리의 크기가 각각 $|s^n_1|$, $|s^n_2|$, … , $|s^n_{k_n}|$라 해 보자.   함수 마지막에서 자식 노드의 결과를 합치는데, 이 과정의 시간복잡도가 $|s^n_i| (1 \\leq i \\leq k_n)$에 대한 이차식이 되는 경우를 생각해보자.   최악의 경우 각 노드에 대해 각 $|s_i|$가 $O(N)$, 노드를 합치는 횟수가 $O(N)$이므로 dfs(root_node)의 시간복잡도는 $O(N^3)$이 될 것 같지만, 실제로는 $O(N^2)$가 된다.   $n$이 루트인 서브트리의 크기를 $|n|$, 이 노드의 결과를 구하는 시간을 $T(n)$이라 해 보자.   또한 자식 노드들의 결과를 합치는 시간복잡도가 $O(이차식)$이라는 것은, 자식 노드 $s^n_1$, $s^n_2$, … 의 결과를 합치는 데 $\\sum_{1 \\leq i \\leq j \\leq k_n} c |s^n_i| |s^n_j|$ ($c$는 상수) 이하의 시간이 걸린다는 뜻이다.    $n$의 자식들 $s^n_i$에 대해 $T(s^n_i) \\leq d|s^n_i|^2 = O(|s^n_i|^2)$ ($d는 상수) 라고 가정해 보자. 그러면,   \\[\\begin{split} &amp;T(n) \\\\ &amp;= \\sum_{1 \\leq i \\leq j \\leq k_n} c \\|s^n_i\\| \\|s^n_j\\| + \\sum_{1 \\leq i \\leq k_n} T(s^n_i) \\\\ &amp;\\leq \\sum_{1 \\leq i \\leq j \\leq k_n} c \\|s^n_i\\| \\|s^n_j\\| + \\sum_{1 \\leq i \\leq k_n} d\\|s^n_i\\|^2 \\\\ &amp;= \\sum_{1 \\leq i \\lt j \\leq k_n} c\\|s^n_i\\| \\|s^n_j\\| + \\sum_{1 \\leq i \\leq k_n} (c+d)\\|s^n_i\\|^2 \\\\ &amp;\\leq \\sum_{1 \\leq i \\lt j \\leq k_n} 2e \\|s^n_i\\| \\|s^n_j\\| + \\sum_{1 \\leq i \\leq k_n} e\\|s^n_i\\|^2 \\quad \\quad ({e &gt; c + d}) \\\\ &amp;= e \\left( \\sum_{1 \\leq i \\leq k_n} \\|s^n_i\\| \\right) ^ 2 \\\\ &amp;= e (\\|n\\|- 1)^2 = O(\\|n\\|^2) \\end{split}\\]  가 되어 노드 $n$에 대해서도 $T(n) = O(|n|^2)$가 성립한다.   또한 base case인 리프 노드에 대해서는 $T(|n|) = O(1) &lt; O(|n|^2)$ 이므로, 수학적 귀납법에 의해 전체 문제를 $O(N)$ 시간에 풀 수 있다.   저걸 잘 일반화하면, 자식 노드의 결과를 합치는 시간복잡도가 $|s^n_1|$, $|s^n_2|$, … , $|s^n_{k_n}|$ 에 대한 $p$차식이면, 전체 문제를 $O(N^p)$ 시간에 풀 수 있다는 것도 알 수 있다.   자식 노드를 합칠 때 자식 노드의 갯수에 대한 다항식 시간이 걸릴 경우   대충 이런 경우를 생각해보자.   void dfs(int node) {     (dp_table[node] 초기화);     for (int next : children[node]) {         dfs(next);     }     for (int next1 : children[node]) {         for(int next2 : children[node]) {             dp_table[node] = foo(dp_table[next1], dp_table[next2]);         }     } } dfs(root_node);   이때 함수 foo는 O(1) 시간에 실행된다고 하자.   이것도 대충 보면 위와 비슷한 이유로 $O(N^3)$ 시간이 걸릴 것 같다. 하지만 이것도 $O(N^2)$다.   위와 마찬가지로, $n$이 루트인 서브트리의 크기를 $|n|$, 이 노드의 자식 노드의 갯수를 $k_n$, 이 노드의 결과를 구하는 시간을 $T(n)$이라 해 보자.   자식 노드들의 결과를 합치는 시간복잡도는 $O({k_n}^2)$, 즉 $c{k_n}^2$ 이하이다 ($c$는 상수).   임의의 노드 $n$의 자식들 $s^n_i$에 대해 $T(s^n_i) \\leq d|s^n_i|^2 = O(|s^n_i|^2)$ ($d는 상수) 라고 가정해 보자. 그러면,   \\[\\begin{split} &amp;T(n) \\\\ &amp;= c{k_n}^2 + \\sum_{1 \\leq i \\leq k_n} T(s^n_i) \\\\ &amp;\\leq c{k_n}^2 + \\sum_{1 \\leq i \\leq k_n} d\\|s^n_i\\|^2 \\\\ &amp;= c \\left( \\sum_{1 \\leq i \\leq k_n} 1 \\right) ^ 2+\\sum_{1 \\leq i \\leq k_n} d\\|s^n_i\\|^2 \\\\ &amp;\\leq c \\left( \\sum_{1 \\leq i \\leq k_n} \\|s^n_i\\| \\right) ^ 2+\\sum_{1 \\leq i \\leq k_n} d\\|s^n_i\\|^2 \\\\ &amp;\\leq e \\left( \\sum_{1 \\leq i \\leq k_n} \\|s^n_i\\| \\right) ^ 2+\\sum_{1 \\leq i \\leq k_n} e\\|s^n_i\\|^2 \\quad \\quad ({e &gt; c + d}) \\\\ &amp;\\leq 2e \\left( \\sum_{1 \\leq i \\leq k_n} \\|s^n_i\\| \\right) ^ 2 \\\\ &amp;= 2e (\\|n\\|- 1)^2 = O(\\|n\\|^2) \\end{split}\\]  가 되어 위와 마찬가지로 수학적 귀납법에 의해 전체 문제를 $O(N^2)$에 해결할 수 있다. 이것도 자식 노드들의 결과를 합치는 시간복잡도는 $O({k_n}^p)$일 때 전체 문제를 $O(N^p)$에 해결할 수 있다고 일반화할 수 있다.   연습문제   BOJ 21141 - Kth Subtree   BOJ 17624 - 검은 돌     References  cubelover의 블로그 - Tree Optimization  ","categories": ["Algorithm"],
        "tags": ["Algorithm-Hard","DP","Tree"],
        "url": "/cs-blog/algorithm/Tree-DP-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84-%EB%B6%84%EC%84%9D/",
        "teaser": null
      },{
        "title": "Jekyll Github 블로그에 LaTeX 수식 사용",
        "excerpt":"이 글에서는 Mathjax를 이용해 Jekyll 블로그에 LaTex 문법을 이용한 수식을 넣는 법을 알아본다.   마크다운 엔진 변경   _config.yml에서 # Conversion으로 시작되는 부분을 다음과 같이 바꾼다. Minimal Mistakes 등 일부 템플릿에서는 기본으로 적용되어 있다.   # Conversion markdown: kramdown highlighter: rouge lsi: false excerpt_separator: \"\\n\\n\" incremental: false   모든 문서에 적용할 경우   _includes/head.html 맨 끝에 아래 내용을 붙여넣으면 끝이다.   &lt;script type=\"text/x-mathjax-config\"&gt;   MathJax.Hub.Config({       TeX: {         equationNumbers: {           autoNumber: \"AMS\"         }       },       tex2jax: {       inlineMath: [ ['$', '$'] ],       displayMath: [ ['$$', '$$'], ['\\\\[', '\\\\]'] ],       processEscapes: true,     }   }); &lt;/script&gt; &lt;script   type=\"text/javascript\"   async   src=\"https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML\" &gt;&lt;/script&gt;   특정 문서에만 적용할 경우   mathjax_support.html 생성   _include 디렉토리에 mathjax_support.html를 생성하고 위 섹션에 있는 코드를 그대로 입력한다.   _layouts/default.html 파일 수정   &lt;head&gt;에 아래 코드를 추가한다.   {% if page.use_math %}   {% include mathjax_support.html %} {% endif %}   YAML front-matter 설정   LaTeX 문법을 사용할 포스트의 front-matter에 use_math: true를 적용   --- title: 2025-03-07-Jekyll-Github-블로그에-LaTeX-수식-사용 categories:   - Others tags:   - Web   - Blog   - Jekyll toc: true use_math: true ---   MathJax 수식 예시   인라인 수식   오일러 공식: $e^{ix} = \\cos(x) + i\\sin(x)$   오일러 공식: $e^{ix} = \\cos(x) + i\\sin(x)$   블록 수식   $$ K(a,b) = \\int \\mathcal{D}x(t) \\exp(2\\pi i S[x]/\\hbar) $$   \\[K(a,b) = \\int \\mathcal{D}x(t) \\exp(2\\pi i S[x]/\\hbar)\\]    References     Jekyll Github 블로그에 MathJax로 수학식 표시하기   MathJax, Jekyll and github pages  ","categories": ["Others"],
        "tags": ["Web","Blog","Jekyll"],
        "url": "/cs-blog/others/Jekyll-Github-%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%97%90-LaTeX-%EC%88%98%EC%8B%9D-%EC%82%AC%EC%9A%A9/",
        "teaser": null
      },{
        "title": "벡터로 두 선분의 교점 구하기",
        "excerpt":"애드혹과 케이스 워크 노가다를 통한 선분 교차 판정은 좀 더럽다. 벡터를 사용해서 케이스를 좀 더 깔끔하게 분류해 선분의 교점을 구해보자.      이 글에서는 편의상 원점과 점 $A$를 잇는 벡터 $\\overrightarrow{OA}$를 $\\overrightarrow{A}$로 표현한다.   요약   원리는 필요 없고 알고리즘만 갖다 쓸 거라면 이걸 그대로 구현하면 된다. 맨 아래에 실제로 작동하는 코드도 있다.      입력 - 두 선분 $\\overline{P_0 P_1}$과 $\\overline{Q_0 Q_1}$   출력 - 두 선분의 교점이 있으면 그 교점을, 두 선분이 한 선분으로 겹치면 그 선분을 반환하며, 두 선분이 만나지 않으면 만나지 않는다고 판단한다.      $u \\leftarrow (\\overrightarrow{P_0 P_1} \\times \\overrightarrow{Q_0 Q_1})$   $u \\ne 0$이라면,            $s \\leftarrow (\\overrightarrow{P_0 Q_0} \\times \\overrightarrow{Q_0 Q_1}) / u \\qquad t \\leftarrow (\\overrightarrow{P_0 Q_0} \\times \\overrightarrow{P_0 P_1}) / u$       $0 \\le s \\le 1$이고 $0 \\le t \\le 1$이면 두 선분은 $\\overrightarrow{OP_0} + s\\overrightarrow{P_0P_1}$에서 교차한다. 그렇지 않으면 교점이 없다.           그렇지 않다면,            $\\overrightarrow{P_0 Q_0} \\times \\overrightarrow{Q_0 Q_1} = 0$, $\\overrightarrow{P_0 Q_0} \\times \\overrightarrow{P_0 P_1} = 0$ 중 하나라도 거짓이면 교점이 없다.       $A_0, \\ A_1 \\leftarrow \\min(P_0, \\ P_1), \\ \\max(P_0, \\ P_1) \\ B_0, \\ B_1 \\leftarrow \\min(Q_0, \\ Q_1), \\ \\max(Q_0, \\ Q_1)$       $L \\leftarrow \\max(A_0, \\ B_0) \\ R \\leftarrow \\min(A_1, \\ B_1)$       $L &lt; R$이면 선분 $LR$에서 겹치고, $L = R$이면 $L$이 교점이고, $L &gt; R$이면 교점이 없다. 이 대소비교는 좌표를 튜플로 두고 통째로 비교하는 것이다.           배경 지식   혹시 벡터에 대해 잘 모르는 상황이라면 이 글을 읽고 오는 것을 추천한다. 고등학교 기하 수준의 배경 지식이 있다면 굳이 안 봐도 되긴 하는데, 선분 교차 판정뿐만 아니라 계산 기하 분야에서 자주 등장하는 알고리즘을 종합적으로 설명하고 있어서 한 번 보면 좋다.   두 벡터를 곱하는 방법 중 하나로 외적(cross product)가 있다. 두 평면벡터의 외적은 그냥 수 하나가 나오고, 다음과 같이 정의된다.   \\[(a_x, a_y) \\times (b_x, b_y) = a_x b_y - a_y b_x\\]  외적의 성질은 다음과 같다.      벡터의 덧셈에 대해 결합법칙과 분배법칙을 만족한다.   외적하는 두 벡터를 교환하면 부호가 반대가 된다. $(\\vec{a} \\times \\vec{b} = - \\vec{b} \\times \\vec{a})$   평행한 두 벡터를 외적하면 $0$이 된다.            두 벡터의 외적이 $0$이 아니면 두 벡터는 평행하지 않다.       같은 벡터를 외적하면 $0$이 된다. $(\\vec{a} \\times \\vec{a} = 0)$.           한편, 두 점 $A$와 $B$를 양 끝점으로 하는 선분 위의 임의의 점 $X$는 다음과 같이 표현할 수 있다.   \\[\\overrightarrow{X} = \\overrightarrow{A} + s\\overrightarrow{AB} \\quad (0 \\le s \\le 1)\\]  풀어서 설명하면, 원점에서 점 $X$까지 가려면 일단 점 $A$까지 간 다음, 선분 $\\overline{AB}$을 따라 이동하면 된다는 것이다. 선분은 점의 집합이기 때문에, 다르게 말하면 저 식이 선분 자체를 벡터로 표현한 것이라고 볼 수도 있다.   알고리즘 구성   위 그림과 같이 두 선분 $\\overline{P_0 P_1}$과 $\\overline{Q_0 Q_1}$이 주어졌을 때 그 교점 $R$이 존재하는지, 존재한다면 어떤 점인지 구할 방법을 생각해보자. 이는 벡터 $\\overrightarrow{R}$이 만족하는 방정식을 써서, 그 식을 만족하는 변수가 존재하는지 확인하고 존재한다면 그 값을 구하는 것으로 수행할 수 있다.     교점 $R$이 존재한다면 다음 두 식을 동시에 만족시키는 실수 $s$와 $t$가 존재한다.   \\[\\begin{aligned} \\overrightarrow{P_0 R} &amp;= s \\overrightarrow{P_0 P_1} &amp;\\quad (0 \\le s \\le 1) \\\\ \\overrightarrow{P_0 R} &amp;= \\overrightarrow{P_0 Q_0} + t \\overrightarrow{Q_0 Q_1} &amp;\\quad (0 \\le t \\le 1) \\\\ \\end{aligned}\\]  식을 정리하면 다음과 같다.   \\[s \\overrightarrow{P_0 P_1} = \\overrightarrow{P_0 Q_0} + t \\overrightarrow{Q_0 Q_1} \\quad (0 \\le s, \\; t \\le 1)\\]  여기서 외적의 결합법칙과 같은 벡터를 외적하면 0이 된다는 사실을 이용하면 $s$와 $t$ 중 하나의 변수를 없앨 수 있다. 양변에 $\\overrightarrow{Q_0 Q_1}$을 외적하면 $t$가 없어지고 다음 식이 나온다.   \\[s (\\overrightarrow{P_0 P_1} \\times \\overrightarrow{Q_0 Q_1}) = (\\overrightarrow{P_0 Q_0} \\times \\overrightarrow{Q_0 Q_1})\\]  $\\overrightarrow{Q_0 Q_1}$ 대신 $\\overrightarrow{P_0 P_1}$을 외적하면 $t$만에 대한 식도 얻을 수 있다.   \\[0 = (\\overrightarrow{P_0 Q_0} \\times \\overrightarrow{P_0 P_1}) + t (\\overrightarrow{Q_0 Q_1} \\times \\overrightarrow{P_0 P_1})\\]  \\[-t (\\overrightarrow{Q_0 Q_1} \\times \\overrightarrow{P_0 P_1}) = t (\\overrightarrow{P_0 P_1} \\times \\overrightarrow{Q_0 Q_1}) = (\\overrightarrow{P_0 Q_0} \\times \\overrightarrow{P_0 P_1})\\]  만약 $\\overrightarrow{P_0 P_1} \\times \\overrightarrow{Q_0 Q_1} \\neq 0$이라면 $s$와 $t$를 바로 구할 수 있다. 여기서부터 $\\overrightarrow{P_0 P_1} \\times \\overrightarrow{Q_0 Q_1} \\neq 0$인 경우, $\\overrightarrow{P_0 P_1} \\times \\overrightarrow{Q_0 Q_1} = 0$인 경우로 케이스를 나눠서 풀어보자.   $\\overrightarrow{P_0 P_1} \\times \\overrightarrow{Q_0 Q_1} \\neq 0$인 경우   $\\overrightarrow{P_0 P_1} \\times \\overrightarrow{Q_0 Q_1} \\neq 0$인 경우는 두 선분 $\\overline{P_0 P_1}$과 $\\overline{Q_0 Q_1}$이 둘 다 길이가 $0$이 아니고 평행하지 않은 경우다. 이 경우엔 앞서 나온 식으로 $s$와 $t$를 바로 계산할 수 있습니다.   \\[s = \\frac{   \\overrightarrow{P_0 Q_0} \\times \\overrightarrow{Q_0 Q_1} } {     \\overrightarrow{P_0 P_1} \\times \\overrightarrow{Q_0 Q_1} } \\qquad  t = \\frac{   \\overrightarrow{P_0 Q_0} \\times \\overrightarrow{P_0 P_1} } {   \\overrightarrow{P_0 P_1} \\times \\overrightarrow{Q_0 Q_1} }\\]  $0 \\leq s, \\; t \\leq 1$이면 교점이 존재하는 것이고, 그렇지 않으면 교점이 없다. 교점의 좌표 $R$은 $\\overrightarrow{R} = \\overrightarrow{P_0} + s\\overrightarrow{P_0 P_1}$로 구할 수 있다.   그 외의 경우   $\\overrightarrow{P_0 P_1} \\times \\overrightarrow{Q_0 Q_1} = 0$인 경우는 두 선분이 평행하거나 길이가 $0$인 경우다. 이 경우엔 두 선분이 겹치는지, 겹치지 않는지를 판단해야 한다.   일단, 네 점이 모두 한 직선 위에 있는지 판단해야 한다. 이는 네 점 $P_0$, $P_1$, $Q_0$, $Q_1$중 세 점을 고르는 모든 경우에 대해 외적이 $0$인지 보면 된다. 즉,   \\[\\begin{aligned} \\overrightarrow{P_0 P_1} \\times \\overrightarrow{P_1 Q_0} &amp;= 0 \\\\ \\overrightarrow{P_0 P_1} \\times \\overrightarrow{P_1 Q_1} &amp;= 0 \\\\ \\overrightarrow{Q_0 Q_1} \\times \\overrightarrow{Q_1 P_0} &amp;= 0 \\\\ \\overrightarrow{Q_0 Q_1} \\times \\overrightarrow{Q_1 P_1} &amp;= 0 \\\\ \\end{aligned}\\]  이 네 등식이 모두 성립하는 지 보면 된다.   위 네 식 중 하나라도 성립하지 않으면 네 점이 한 직선 위에 있지 않은 것인데, 두 선분이 평행하지 않은 경우는 앞에서 이미 걸렀으므로 이때는 반드시 두 선분이 평행하고 만나지 않는 경우다. 따라서 이 때는 교점이 존재하지 않는다.   마지막으로 네 점이 한 직선 위에 있는 경우만 남았다.     $A_0 = \\min(P_0, P_1)$, $A_1 = \\max(P_0, P_1)$, $B_0 = \\min(Q_0, Q_1)$, $B_1 = \\max(Q_0, Q_1)$로 두자.. 이때 점의 비교 기준은 우선 $x$좌표가 작은 것이 더 작은 점이고, $x$좌표가 같다면 $y$좌표가 작은 것이 더 작은 점이다. 이렇게 하면 $\\overrightarrow{A_0 A_1}$과 $\\overrightarrow{B_0 B_1}$의 방향이 같아진다.     그런 다음, $L = \\max(A_0, B_0)$, $R = \\min(A_1, B_1)$이라고 하자. $L \\leq R$이면 두 선분이 겹치는 것이고, $L = R$이면 교점이 $L$이고, $L &gt; R$이면 교점이 없다.   오버플로 주의   내부 계산을 정수형 또는 분수로만 진행한다면 오버플로가 좀 많이 날 수 있다. 점의 좌표 범위가 $10^9$ 이내라면, $s$와 $t$의 분자는 최대 $10^{18}$, 교점의 좌표는 여기에 벡터를 다시 곱하므로 분자가 최대 $10^{27}$까지 늘어난다. 최종 답안이 정확한 분수 형태일 필요가 없다면 적당한 타이밍에 부동소수점으로 바꿔주자. 최종 답안도 분수 형태로 만들고 싶다면 입력값으로 주어지는 좌표의 세제곱까지 처리할 수 있어야 한다. 예를 들어, 입력값의 범위가 i32라면 마지막에는 i128로 계산해야 한다.   이런 게 귀찮으면 파이썬 등 BigInt를 지원하는 언어를 쓰자.   구현   using namespace std; typedef long long ll; typedef long double ld; typedef pair&lt;ll, ll&gt; pll; typedef pair&lt;ld, ld&gt; pld;   ll cross(pll a, pll b) {     return a.first * b.second - a.second * b.first; }  pll sub(pll a, pll b) {     return {a.first - b.first, a.second - b.second}; }  // {0, {0, 0}}: no intersection // {1, {x, y}}: intersection at (x, y) // {2, {0, 0}}: two segments are overlapped (infinite intersections) pair&lt;int, pld&gt; intersect(pll p0, pll p1, pll q0, pll q1) {     pll u = sub(p1, p0);     pll v = sub(q1, q0);     ll det = cross(u, v);     if (det &lt; 0) {         p0.swap(p1);         u.first *= -1;         u.second *= -1;         det *= -1;     }     if (det != 0) {         pll w = sub(q0, p0);         ll cross_wu = cross(w, u);         ll cross_wv = cross(w, v);         if (cross_wu &lt; 0 || cross_wu &gt; det || cross_wv &lt; 0 || cross_wv &gt; det) {             return {0, {0, 0}};         }         ld s = (ld)cross_wv / det;         ld t = (ld)cross_wu / det;         return {1, {p0.first + u.first * s, p0.second + u.second * s}};     } else {         if (cross(sub(q0, p0), u) != 0 || cross(sub(q0, p1), u) != 0 || cross(sub(p0, q0), v) != 0 || cross(sub(p0, q1), v) != 0) {             return {0, {0, 0}};         }         pll a0 = min(p0, p1);         pll a1 = max(p0, p1);         pll b0 = min(q0, q1);         pll b1 = max(q0, q1);         pll l = max(a0, b0);         pll r = min(a1, b1);         if (l &lt; r) {             return {2, {0, 0}};         } else if (l == r) {             return {1, {(ld)l.first, (ld)l.second}};         }         return {0, {0, 0}};     } }  ","categories": ["Algorithm"],
        "tags": ["Algorithm-Normal","Geometry"],
        "url": "/cs-blog/algorithm/%EB%B2%A1%ED%84%B0%EB%A1%9C-%EB%91%90-%EC%84%A0%EB%B6%84%EC%9D%98-%EA%B5%90%EC%A0%90-%EA%B5%AC%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "KHSPC 뒷북 후기 + 비공식 에디토리얼 (1)",
        "excerpt":"이 대회는 경희대학교에서 학생 주도로 열리는 최초의 PS 대회다. 그리고 내가 처음으로 문제를 출제하고 운영진으로 참가한 대회다. 이걸 졸업한 뒤에야 처음으로 하게 될 줄은 몰랐긴 했는데… 지금 2학년인 후배가 대회 열려고 열심히 뛰어다니는 걸 보니까 많은 생각이 든다. 대학 다닐 때 좀 더 주도적으로 뭔가 했어야 됐겠다는 아쉬움도 남지만, 지금이라도 뭔가 한 게 다행일지도 모른다.   대회 운영이나 진행 중에 느낀 점이라면, 문제 난이도 조절을 좀 잘못한 것 같다. 대회 시작 이전에도 실버 상위 ~ 골드 중위 수준에 너무 많은 문제가 몰려 있는 것 아니냐는 의견이 좀 있긴 했다 (C~H). 그런데 본 대회에서는 그냥 너무 어려워서 문제였던 것 같다. 본 대회 참가자가 40명이었는데, 1솔 이상이 21명, 2솔 이상이 10명이었다. 상위권 참가자들은 나름 많이 풀긴 했는데, 대회 참가자 대부분이 2솔 이하라면 솔직히 의욕이 많이 꺾일 것 같긴 하다. 특히 B번 문제가 진짜로 2번째로 쉬운 문제이긴 한데 실수할 구석이 꽤 많아서 이런 결과에 큰 영향을 줬을 것 같다. 다음에 교내에서 이런 대회를 연다면 중하위 난이도 문제를 더 쉽게 내고 저난이도 문제에서는 case work나 예외처리 등 실수할 곳이 많이 없게 깔끔하게 풀리는 문제를 좀 늘려야 될 것 같다.   본 대회는 끝난 지 벌써 한 달쯤 됐긴 했다. 주최자 일정이랑 다른 대회 일정이랑 겹쳐서 본 대회 2주 뒤로 미뤄졌던 오픈 콘테스트도 끝난 지 좀 되긴 해서 이걸 이제야 올리는 게 맞나 싶긴 한데 지금이라도 써 보는 게 맞는 것 같다.   문제가 13문제나 되서 이 글에 모든 문제의 에디토리얼과 후기를 쓰진 못할 것 같다. 여기서는 쉬운 편인 8문제만 적겠다.   대회 링크   에디토리얼   문제 번호는 본 대회 기준이며, 출제진 및 검수진이 쉽다고 느꼈던 문제일수록 앞쪽에 있다.   A. 태권도와 복싱을 합한 운동  문제 링크   그냥 시키는 걸 풀면 된다. 다만 문자열에 모음이 없거나 첫 모음 뒤 자음이 없는 경우에 답이 없다는 걸 조심하자. C++ 등 문자열을 다루기 귀찮은 언어에서 플래그를 이용해 자음/모음의 등장 여부를 따지는 경우라면 특히 더 조심하자. 본 대회 후 스코어보드를 보면 제일 쉬운 문제치곤 좀 어렵지 않았나, 정확히는 실수할 거리가 좀 많지 않았나 생각이 든다.   def get_first_syllable(a):     for i in range(len(a) - 1):         if a[i] in \"aeiou\" and not a[i + 1] in \"aeiou\":             return a[:i + 1]     return \"\"  def main():     a = input()     b = input()      aa = get_first_syllable(a)     bb = get_first_syllable(b)      if aa == \"\" or bb == \"\":         print(\"no such exercise\")     else:         print(aa + bb)  if __name__ == \"__main__\":     main()   B. 간단한 동전 문제 (Easy)  문제 링크   간단한 case work + brtue force 문제다. 동전의 갯수 $N$에 따라 다음과 같이 풀면 된다.           $N = 0$       $M = 0$이라면 정답은 $0$, 아니면 $-1$이다.       $N = 1$                     $P_1 = 0$일 때           $M$이 $0$이면 정답은 $0$, 아니면 $-1$이다.                        $P_1 \\neq 0$일 때           $M$을 $P_1$으로 나눈 나머지가 $0$이고 $M / P_1 \\geq 0$이면 $M / P_1$, 아니면 $-1이 정답이다.                        $N = 2$       1번째 동전을 내는 갯수와 2번째 동전을 내는 갯수를 각각 $x_1, x_2$라고 할 때, $x_1$과 $x_2$를 $0 \\leq x_1, x_2 \\leq 2000$ 정도의 범위에서 브루트포스를 돌리면 된다. $x_1 P_1 + x_2 P_2 = M$을 만족하는 $(x_1, x_2)$ 중 $x_1 + x_2$가 최소인 것을 찾으면 된다. 만약 그런 $(x_1, x_2)$가 없다면 $-1$을 출력한다.       $x_1$ 하나에 대해서만 브루트포스를 돌리고 $x_2$는 $M - x_1 P_1$을 $P_2$로 나눈 후 나머지가 $0$, 몫이 양수인지를 확인하는 방법도 있긴 하다. 하지만 $P$가 $0$인 경우를 고려해야 하므로 이 방법은 조금 더 복잡하다.       분명히 두 번째로 쉬운 문제라고 냈는데, 본 대회에서 정답률이 5%대(…)가 나왔다. $N = 0$이거나 $P$ 중에 $0$이 있는 경우를 잘 생각하지 못해서 그런 것 같긴 한데… 그 와중에 상위권 참가자들은 이 문제의 Hard 버전을 먼저 풀기 위해 이걸 안 풀고 넘기고 있었는데, 그 문제도 굉장히 치명적인 함정이 있던 문제였다.   C. 부도덕한 그래프 (Easy)  문제 링크   모든 가능한 $(x, y, z)$ 쌍에 대해 브루트포스를 돌리면 $O(N^3)$이라 시간 초과가 난다. 정점 대신 간선을 기준으로 생각하면 $O(M^2)$ 시간복잡도로 풀 수 있다.   모든 순서 없는 간선 쌍 ${e_i, e_j} = {(u_1, v_1), (u_2, v_2)}$ (단, $i &lt; j$)에 대해 다음과 같은 조건을 만족하는지 확인한다.      $u_1 \\neq u_2$   $v_1 = v_2$   $u_1$과 $u_2$ 사이에 간선이 없다   이 조건을 만족하는 간선 쌍의 개수를 세면 된다. 이때, 각 $u_1$과 $u_2$ 사이에 간선이 없다는 조건은 $O(N^2)$ 시간 및 메모리 복잡도로 인접 행렬을 전처리하면 $O(1)$로 확인할 수 있다. 따라서 전체 시간 복잡도는 $O(M^2 + N^2)$이 된다.   구현 자체는 꽤 간단한데, PS를 많이 안 해본 사람들은 저런 발상을 하는 게 쉽지 않을 것 같다. 그래도 아이디어만 제대로 떠올리면 실수할 여지는 거의 없는 것 같다.   #include &lt;bits/stdc++.h&gt;  using namespace std; typedef long long ll; typedef long double ld; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; const ll MOD9 = 998244353; const ll MOD1 = (ll)1e9 + 7;  int main() {     ios_base::sync_with_stdio(false);     cin.tie(nullptr);     cout.tie(nullptr);      int n, m;     cin &gt;&gt; n &gt;&gt; m;     vector&lt;vector&lt;int&gt;&gt; adj_mat(n, vector&lt;int&gt;(n));     vector&lt;pii&gt; edges(m);     for (int i = 0; i &lt; m; i++) {         int s, e;         cin &gt;&gt; s &gt;&gt; e;         s--, e--;         edges[i] = {s, e};         adj_mat[s][e] = 1;     }      ll ans = 0;     for (int i = 0; i &lt; m; i++) {         int u1 = edges[i].first, v1 = edges[i].second;         for (int j = i + 1; j &lt; m; j++) {             int u2 = edges[j].first, v2 = edges[j].second;             if (u1 == u2) {                 continue;             }             if (v1 != v2) {                 continue;             }             if (!adj_mat[u1][u2] &amp;&amp; !adj_mat[u2][u1]) {                 ans++;             }         }     }      cout &lt;&lt; ans &lt;&lt; endl;      return 0; }   D. 부분 수열 고르기  문제 링크   임의의 자연수 $L$ ($L \\leq N$)에 대해, 주어진 등차수열에서 $L$개의 원소를 골라 합을 $M$으로 만들 수 있는지 $O(1)$만에 판단할 수 있다.   수열 $A$에서 제일 작은 원소 $L$개를 골랐을 때의 합은 초항 $a$ 공차 $d$인 등차수열의 첫 $L$개 원소의 합을 구하는 것과 같다. 즉, $M \\leq L \\cdot a + d \\cdot \\frac{L \\cdot (L - 1)}{2}$이어야 한다.   반대로, 제일 큰 원소 $L$개를 골랐을 때의 합은 초항 $a + d \\cdot (N - L)$ 공차 $d$인 등차수열의 첫 $L$개 원소의 합을 구하는 것과 같다. 즉, $M \\geq L \\cdot (a + d \\cdot (N - L)) + d \\cdot \\frac{L \\cdot (L - 1)}{2}$이어야 한다.   그리고 $M$을 $d$로 나눈 나머지에 대해서도 생각해야 한다. $A$에서 수를 어떻게 선택하든, 그 합은 $La + pd$ ($p$는 자연수) 꼴이 된다. 따라서 $M \\equiv La \\pmod{d}$이어야 한다.   정리하면,      $M \\leq L \\cdot a + d \\cdot \\frac{L \\cdot (L - 1)}{2}$   $M \\geq L \\cdot (a + d \\cdot (N - L)) + d \\cdot \\frac{L \\cdot (L - 1)}{2}$   $M \\equiv La \\pmod{d}$   어떤 $L$이 이 세 조건을 만족한다면, 반드시 $L$개의 원소를 골라 합을 $M$으로 만들 수 있다. 브루트포스를 통해 가장 큰 $L$을 $O(N)$만에 찾을 수 있고, $L$을 찾았다면 합을 $M$으로 만드는 원소를 실제로 찾아야 한다.   먼저, 모든 원소를 최소값으로 선택하고 이 때의 부분 수열을 $A’$, $A’$의 합을 $S$라고 하자. 이때, $S = L \\cdot a + d \\cdot \\frac{L \\cdot (L - 1)}{2}$이고 $A’$은 오름차순으로 정렬되어 있다. $i = L$로 시작하고, $S &lt; M$인 동안 다음을 반복하면 된다.      $S - M \\leq d \\cdot (N - L)$이면, $A’$의 $i$번째 원소에 $S - M$을 더하고, $S$를 $M$으로 바꾼 후 루프를 종료한다.     $A’$의 $i$번째 원소를 현재 쓰이지 않은 $A$의 가장 큰 원소 ($=A’_{i} + d \\cdot (N - L)$)로 바꾼다.     $S$를 $S + d \\cdot (N - L)$로 바꾼다.     $i$를 $i - 1$로 바꾼다.    위 과정은 $A’$의 $i$번째 원소와 현재 쓰이지 않은 $A$의 가장 큰 원소의 차가 $d \\cdot (N - L)$이라는 관찰에서 나온 것이다. $L = 3$, $N = 7$인 경우를 예시로 들면, 맨 처음에 $A’ = [A_1, A_2, A_3]$이다. 맨 뒤 원소인 $A_3$은 $A_7$로 바꿀 수 있으므로 두 수의 차이는 $d \\cdot (7 - 3) = 4d$가 된다. 마찬가지로 $A_2$는 $A_7$이 이미 사용되었으므로 최대 $A_6$으로 바꿀 수 있고, 두 수의 차이는 마찬가지로 $d \\cdot (6 - 2) = 4d$가 된다.   이 과정의 시간복잡도는 $O(N)$이다. 따라서 전체 시간복잡도는 $O(N) + O(N) = O(N)$이 된다.   기본적인 발상 자체는 꽤 쉽지만, 식 정리나 구현 과정이 꽤 복잡한 문제다. 바로 앞 문제랑 비교하면 그런 점이 특히 더 두드러지는 것 같다.   #include &lt;bits/stdc++.h&gt;   using namespace std; typedef long long ll; typedef long double ld; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; const ll MOD9 = 998244353; const ll MOD1 = (ll)1e9 + 7;   int main() {     ios_base::sync_with_stdio(false);     cin.tie(nullptr);     cout.tie(nullptr);       ll n, a, d, m;     cin &gt;&gt; n &gt;&gt; a &gt;&gt; d &gt;&gt; m;       for (int l = n; l &gt;= 1; l--) {         // check if l is valid         ll min_sum = a * l + d * l * (l - 1) / 2;         ll max_sum = (a + d * (n - l)) * l + d * l * (l - 1) / 2;         if (min_sum % d != m % d) {             continue;         }         if (m &lt; min_sum || m &gt; max_sum) {             continue;         }          // l is valid, construct the answer         ll diff = (m - min_sum) / d;           vector&lt;ll&gt; ans(l);         for (int i = 0; i &lt; l; i++) {             ans[i] = a + d * i;         }           ll movable = n - l;         for (int i = l - 1; i &gt;= 0; i--) {             if (diff == 0) {                 break;             }             else if (diff &gt;= movable) {                 ans[i] += d * movable;                 diff -= movable;             }             else {                 ans[i] += d * diff;                 diff = 0;             }         }           cout &lt;&lt; l &lt;&lt; \"\\n\";         for (int i = 0; i &lt; l; i++) {             cout &lt;&lt; ans[i] &lt;&lt; \" \";         }         return 0;     }       cout &lt;&lt; -1;     return 0; }   E. 잔돈 싫어  문제 링크   흔한 2차원 DP 문제다. 편의상 문제에서 주어지는 모든 금액을 10으로 나누고 문제를 생각하자. 또한, $A$ 중 값이 (10으로 나눈 후) 50 이상 2000 미만인 원소만 포함한 $A’$를 생각하자.   $dp[i][j]$를 $A’$의 첫 $i$개 원소까지 봤을 때, $50$으로 나눈 나머지가 $j$인 것 중 환불받을 수 있는 최대 금액이라고 하자. 만약 $50$으로 나눈 나머지를 $j$로 만들도록 환불이 불가능하면 $-\\infty$이라고 하자. 그러면 초기조건과 점화식을 다음과 같이 세울 수 있다.   \\[dp[0][j] =  \\begin{cases} 0 &amp; \\text{if } j = 0 \\\\ -\\infty &amp; \\text{otherwise } \\end{cases} \\quad (0 \\leq i &lt; 50)\\]  \\[dp[i][j] = \\max\\left \\{ \\begin{array}{l} dp[i - 1][j], \\\\ dp[i - 1][(j - A'[i - 1]) \\bmod 50] + A'[i] \\end{array}  \\right.  \\\\  (1 \\leq i &lt; N', \\ 0 \\leq j &lt; 50)\\]  $A’$의 길이를 $N’$이라 했을 때, 정답은 $dp[N’][0]$이다.   PS를 어느 정도 해 봤다면 앞 두 문제보다 쉽게 느낄 만한 문제다. 현재 solved.ac에서는 난이도가 C = E &lt; D로 매겨저 있고, 나도 대충 비슷하게 느낀다. 본 대회에서는 PS 경험이 있는 참가자가 적은 걸 반영해서 이런 순서로 매겨진 것 같다.   F. MEX의 MEX  문제 링크   전형적인 이분 탐색 문제다. 부분 문자열을 만들 때 길이가 1인 것부터 시작해 길이를 하나씩 늘리는 게 최선인 건 명백하고, 이런 식으로 크기가 $k$인 집합 $S$를 만들었을 때 $S$의 점수는 $k+1$이다.   각 $N$이 주어질 때마다 $k$에 대해 이분 탐색을 돌린다. 어떤 $k$가 주어졌을 때, $S$의 점수가 $k+1$이 되게 하는 가장 짧은 문자열의 길이를 $L$이라고 하자. 이분 탐색을 통해 $L \\leq N$인 가장 큰 $k + 1$를 찾으면 그게 정답이다.   $L$을 구하는 방법을 생각해보자. 일단 충분히 긴 MEX 문자열과 어떤 $k$가 주어졌을 때, 길이가 $k$ 이하인 모든 부분 문자열을 안 겹치게 만드는 방법을 생각해 보자. 단순한 방법은 그냥 앞에서부터 길이 0, 1, … $k$인 부분 문자열을 하나씩 고르는 것이다. 다음은 $k=5$인 경우의 예시이다.   \\[\\underline{M}EX \\ \\underline{ME}X \\ \\underline{MEX} \\ \\underline{MEX \\ M}EX \\ \\underline{MEX \\ ME}X ...\\]  길이 0인 부분 문자열을 제외하고 일반화하면 첫 3개 부분 문자열은 \"MEX\" 1개씩, 그 다음 3개 부분 문자열은 \"MEX\" 2개씩, 그 다음 3개 부분 문자열은 \"MEX\" 3개씩, … 이런 식으로 \"MEX\"를 반복해 길이 $k$ 이하인 부분 문자열을 반드시 모두 고를 수 있다. 등차수열 합을 잘 활용하면 다음과 같은 결과를 얻는다.   \\[L \\leq 9 \\cdot \\frac{\\lfloor {k / 3} \\rfloor (\\lfloor {k / 3} \\rfloor+ 1)}{2} + (k \\ \\% \\ 3) \\cdot 3 \\cdot (\\lfloor {k / 3} \\rfloor + 1)\\]  $k$가 3개씩 묶이는 부분에서는 $9 \\cdot \\frac{\\lfloor {k / 3} \\rfloor (\\lfloor {k / 3} \\rfloor+ 1)}{2}$가 된다. 이는 길이 $\\lfloor {k / 3} \\rfloor$이고 초항 및 공차가 각각 3인 등차수열이 3개 있을 때의 합이다. 나머지 부분은 길이 $3 \\cdot (\\lfloor {k / 3} \\rfloor + 1)$인 문자열이 $k \\ \\% \\ 3$개 추가된 것이다.   그런데 위 예시를 잘 보면 문자열 순서를 바꿔서 마지막 부분 문자열이 \"M\"으로 끝나게 할 수 있는 것을 알 수 있다. 저 예시에서는 \"MEXM\"과 \"MEXME\"의 위치를 바꾸면 된다. 즉, \"MEX\"를 반복한 문자열에서 마지막 \"EX\"를 없앨 수 있다. 따라서 $L$의 진짜 값은 다음과 같다.   \\[L = 9 \\cdot \\frac{\\lfloor {k / 3} \\rfloor (\\lfloor {k / 3} \\rfloor+ 1)}{2} + (k \\ \\% \\ 3) \\cdot 3 \\cdot (\\lfloor {k / 3} \\rfloor + 1) - 2\\]  이분 탐색을 쓰지 않는 풀이가 있긴 하다. 저 위의 $L$에 대한 등식에서 뒤쪽 항을 날리고, $\\lfloor k / 3 \\rfloor$을 $k/3$으로 바꾸면 $k$에 대한 이차방정식을 풀 수 있다. 그렇게 나온 $k$ 값 주변 범위를 탐색해서 진짜로 가능한 가장 큰 $k$를 찾을 수 있다.   이게 이분 탐색인 걸 알아차리려면 비슷한 문제를 몇 번 풀어본 적은 있어야 할 것 같다. 그리고 그걸 알더라도 발상이나 식 정리가 아주 쉬운 편은 아니고, 특히 식 정리 중 실수할 가능성이 꽤 큰 것 같다. 그나마 구현량은 매우 적은 편이다.   // #include \"atcoder/all\" #include &lt;bits/stdc++.h&gt;  using namespace std; typedef long long ll; typedef long double ld; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; const ll MOD9 = 998244353; const ll MOD1 = (ll)1e9 + 7;  int main() {     ios_base::sync_with_stdio(false);     cin.tie(nullptr);     cout.tie(nullptr);      ll t;     cin &gt;&gt; t;     while (t--) {         ll n;         cin &gt;&gt; n;          ll ans = 0;         ll l = 0, r = 2e9 + 2;         while (l &lt; r) {             ll mid = (l + r) / 2;             ll cur = (mid / 3) * (mid / 3 + 1) / 2 * 9;             cur += (mid % 3) * (mid/ 3 + 1) * 3;             cur -= 2;             if (cur &lt;= n) {                 ans = max(ans, mid);                 l = mid + 1;             }             else {                 r = mid;             }         }          cout &lt;&lt; ans + 1 &lt;&lt; '\\n';     }      return 0; }   G. 간단한 동전 문제 (Hard)  문제 링크   앞에서도 말했지만 함정 문제다. 뭔가 knapsack DP 문제 같지만 그렇게 풀면 상태 전이 횟수가 엄청나게 많아서 망한다. 실제로는 백준 1697번과 비슷하게 묵시적으로 정의된 그래프에서 BFS를 돌리는 문제다.   적당히 큰 자연수 $L$에 대해 각 정수 $-L, -L + 1, … L - 1, L$을 각각 정점으로 생각하고, 각 정점에 최대 $N$개의 간선이 있다고 생각할 수 있다. 각 정점 $i$에서 $i + P_j$ ($j = 1, 2, …, N$)로 가는 간선이 있다고 생각하면, 이 그래프에서 시작 정점 $0$에서 끝 정점 $M$으로 가는 최단 경로의 길이를 구하는 문제로 바꿀 수 있다.   다만 탐색 범위의 상한을 $L = M$ 같은 식으로 잡으면 안 된다. 예시로, $M = 1$이고 $P = [-999, 1000]$ 같은 경우를 생각해 볼 수 있다. 주어진 문제 조건에서는 $L = 12000$ 정도로 잡으면 될 거다.   본 대회에서 우승 후보급 참가자들이 이걸 knapsack으로 접근하는 걸 대회 중 운영진들이 봤는데, 다들 마음 아파하던 것 같다… 본 대회에서 1~3등은 이걸 못 풀었고, 4등 참가자 딱 한 명이 풀었다.   H. 3단 가시   문제 링크   맵의 길이 $N$이 충분히 작다면, $O(N)$ 시간복잡도의 DP로 풀 수 있었을 문제다. 현재 제한에서도 큰 아이디어는 다르지 않기 때문에 일단 이 풀이부터 살펴보자.   $T[i]$를 좌표 $i$에 가시가 있는지의 여부, $dp[i][j]$ ($0 \\leq i \\leq N$, $0 \\leq j \\leq 3$)를 좌표 $i$에서 공중에 $j$프레임동안 떠 있던 상태가 될 수 있는지의 여부라고 정의하자. $j = 0$인 경우는 공중에 떠 있지 않은 상태라고 생각하면 된다. 그러면 초기조건과 점화식은 다음과 같다.   \\[\\begin{aligned} dp[0][j] &amp;=  \\begin{cases} 1 &amp; \\text{if } j = 0 \\\\ 0 &amp; \\text{otherwise} \\end{cases} &amp;&amp; (0 \\leq j &lt; 3) \\\\ \\\\ dp[i][0] &amp;=  \\begin{cases} 1 &amp; \\text{if } (dp[i - 1][0] \\ \\text{or} \\ dp[i - 1][3]) \\ \\text{and} \\ \\text{not} \\  T[i] \\\\ 0 &amp; \\text{otherwise} \\end{cases} &amp;&amp; (1 \\leq i \\leq N) \\\\ \\\\ dp[i][j] &amp;= dp[i - 1][j - 1] &amp;&amp; (1 \\leq i \\leq N,\\ 1 \\leq j \\leq 3) \\end{aligned}\\]  물론 이걸 그냥 쓸 수는 없다. 하지만 한 번 점프할 때 3프레임만 떠 있다는 사실을 생각하면, 충분히 먼 가시끼리는 서로 영향을 주지 않는다는 것을 알 수 있다. 즉, 가까이 붙어 있는 가시끼리 그룹을 묶어서, 각 그룹별로 위와 같은 DP를 돌리면 된다. 이때 각 그룹의 첫 가시 좌표와 끝 가시 좌표를 $l$과 $r$이라고 하자. 첫 그룹의 경우, $l$이 $3$ 이하라면 범위 $[0, r]$에서 위와 정확히 같은 DP 점화식을 적용하면 된다. 첫 그룹에서 $l$이 $3$ 이상이거나 두 번째 이후 그룹에서는 각 그룹의 첫 가시 좌표 $l$부터 시작해서 $r$까지 DP를 돌리면 되는데, 초기조건이 다음과 같이 바뀐다.   \\[dp[l][j] = \\begin{cases} 0 &amp; \\text{if } j = 0 \\\\ 1 &amp; \\text{otherwise} \\end{cases} \\quad (0 \\leq j \\leq 3)\\]  각 그룹마다 $dp[r + 1]$을 확인한다. 모든 그룹에서 $dp[r + 1]$ 중 $1$이 있으면 POSSIBLE, 없으면 IMPOSSIBLE을 출력한다.   본 대회 중 이 문제를 푼 사람은 4명이다. 문제 위치에 비하면 꽤 많이 푼 것 같다. F와 G가 각각 2명, 1명 풀었다.   // #include \"atcoder/all\" #include &lt;bits/stdc++.h&gt;  using namespace std; typedef long long ll; typedef long double ld; typedef pair&lt;int, int&gt; pii; typedef pair&lt;ll, ll&gt; pll; const ll MOD9 = 998244353; const ll MOD1 = (ll)1e9 + 7;  int main() {     ios_base::sync_with_stdio(false);     cin.tie(nullptr);     cout.tie(nullptr);      int t;     cin &gt;&gt; t;     while (t--) {         ll n, x;         cin &gt;&gt; n &gt;&gt; x;         vector&lt;ll&gt; p(x);         for (int i = 0; i &lt; x; i++) {             cin &gt;&gt; p[i];         }          vector&lt;vector&lt;ll&gt;&gt; groups(1);         groups[0] = {p[0]};         for (int i = 1; i &lt; x; i++) {             ll prev = p[i - 1];             if (p[i] - prev &lt;= 10) {                 groups.back().push_back(p[i]);             } else {                 groups.push_back({p[i]});             }         }          bool ans = true;         for (int i = 0; i &lt; groups.size(); i++) {             vector&lt;array&lt;bool, 4&gt;&gt; dp;             vector&lt;bool&gt; gasi;             if (i == 0 &amp;&amp; groups[i].front() &lt;= 3) {                 dp.resize(groups[i].back() + 1);                 gasi.resize(groups[i].back() + 1, false);                 dp[0] = {true, false, false, false};                 for (ll p : groups[i]) {                     gasi[p] = true;                 }                  for (ll j = 1; j &lt;= groups[i].back(); j++) {                     dp[j] = {false, false, false, false};                     dp[j][0] = !gasi[j] &amp;&amp; (dp[j - 1][0] || dp[j - 1][3]);                     for (int k = 1; k &lt;= 3; k++) {                         dp[j][k] = dp[j - 1][k - 1];                     }                 }                 auto fin = dp.back();                 if (!fin[0] &amp;&amp; !fin[1] &amp;&amp; !fin[2] &amp;&amp; !fin[3]) {                     ans = false;                     break;                 }             } else {                 dp.resize(groups[i].back() - groups[i].front() + 1);                 gasi.resize(groups[i].back() - groups[i].front() + 1, false);                 dp[0] = {false, true, true, true};                 for (ll p : groups[i]) {                     gasi[p - groups[i].front()] = true;                 }                  for (ll j = 1; j &lt;= groups[i].back() - groups[i].front(); j++) {                     dp[j] = {false, false, false, false};                     dp[j][0] = !gasi[j] &amp;&amp; (dp[j - 1][0] || dp[j - 1][3]);                     for (int k = 1; k &lt;= 3; k++) {                         dp[j][k] = dp[j - 1][k - 1];                     }                 }                 auto fin = dp.back();                 if (!fin[0] &amp;&amp; !fin[1] &amp;&amp; !fin[2] &amp;&amp; !fin[3]) {                     ans = false;                     break;                 }             }         }          if (ans) {             cout &lt;&lt; \"POSSIBLE\\n\";         } else {             cout &lt;&lt; \"IMPOSSIBLE\\n\";         }     }      return 0; }   정리   원래 우승권 경쟁은 이 8문제를 풀고 나머지 5문제 중 1개, 많으면 2개 정도 푸는 선에서 결정될 거라고 생각했다. 그런데 예상과 좀 다르게 되긴 했다.   일단 이 글 도입부에서도 나름 소감을 적어놨고, 어차피 2부를 올려야 되기 때문에 더 할 말이 있으면 2부 포스트에서 하겠다.  ","categories": ["Contest"],
        "tags": ["Contest","Editorial","KHSPC","KHSPC-2025"],
        "url": "/cs-blog/contest/KHSPC-%EB%92%B7%EB%B6%81-%ED%9B%84%EA%B8%B0-+-%EB%B9%84%EA%B3%B5%EC%8B%9D-%EC%97%90%EB%94%94%ED%86%A0%EB%A6%AC%EC%96%BC-(1)/",
        "teaser": null
      },{
        "title": "KHSPC 뒷북 후기 + 비공식 에디토리얼 (2)",
        "excerpt":"J번까지의 풀이를 포함한 이전 글은 여기서 확인할 수 있다. 지금은 바로 본론으로 들어가겠다.   대회 링크   에디토리얼   문제 번호는 본 대회 기준이며, 출제진 및 검수진이 쉽다고 느꼈던 문제일수록 앞쪽에 있다.   I. 쿠옹이의 궁금증  문제 링크   상당히 고통스러운(…) 구현 문제다. 정해가 좀 많은데, segment tree DP, 백트래킹, meet in the middle 등이 있다는 것 같다. 여기서는 내가 푼 방법인 meet in the middle 풀이를 소개한다.   대략 $M \\leq 6$ 정도의 입력에서는 브루트포스로 문제를 풀 수 있다. $M \\geq 7$일 때는 길이 $M$인 식이 모두 (수식)(연산자)(수식) 형태 또는 (수식)(연산자)(수)(연산자)(수식) 형태라는 것을 이용해 풀 수 있다. $M &gt;\\geq 7$ 이면 $N$의 범위 제한 때문에 연산자 없이 그냥 하나의 수인 경우는 없다.   1. (수식)(연산자)(수식) 형태   길이가 6 이하인 모든 식에 대해, 다음 경우의 수를 미리 구해두자.      $count[i][j][k]$ := 길이가 $i$, 연산자 위치가 $j$인 식의 값이 $k$인 경우의 수   문자열이 0-based index라고 가정하고 예를 들면, $1+2+3$라는 식은 $i=5$, $j=(1, 3)$, $k=6$인 경우의 식에 해당한다.   이때 $k$ 값의 범위는 $-2.5 \\cdot 10^5 \\leq k \\leq 2.5 \\cdot 10^5$ 정도로 하면 된다. 이 범위 밖의 값을 갖는 식에 대해서는 경우의 수를 따로 세지 말자.                  이제 위 형태를 만족하는 길이 $M$인 식의 경우의 수를 구하기 위해, 다음 조건을 만족하는 모든 식 길이의 쌍 $(       l       ,       r       )$을 구하자. $       l       $은 왼쪽 수식의 길이, $       r       $은 오른쪽 수식의 길이이다.                                              $           l           +           r           = M - 1$ (여기서 $           x           $는 식 $x$의 길이)                                                           $1 \\leq           l           \\leq 6$, $1 \\leq           r           \\leq 6$                                          아까 $count$를 구할 때 길이 정보뿐만 아니라 연산자 위치 정보까지 구했으므로, 이런 식으로 구한 식의 연산자 위치도 알 수 있다. 왼쪽 수식의 연산자 위치를 $j_l$라고 하고, 오른쪽 수식의 연산자 위치를 $j_r$라고 하자. 모든 $(       l       ,       r       , j_l, j_r)$ 튜플 중 최종 식의 연산자 위치가 중복되지 않고 최종 수식의 값이 $N$인 경우의 수를 구하면 된다.           그런데 이러면 문제가 있다. 연산자가 수식 중앙에서 너무 멀리 떨어져 있는 식은 이 형태를 따르지 않는다. 예를 들면, $12+12345+12$ 같은 식은 위 방법으로 구할 수 없다. 구체적으로는, $M=11$ 기준으로 수식 정중앙 또는 정중앙에서 한 칸 떨어진 곳에 연산자가 있어야 한다. 이것 때문에 아래 방법도 필요하다.   2. (수식)(연산자)(수)(연산자)(수식) 형태   $M=11$일 때, 연산자가 수식 정중앙에서 두 칸씩 떨어져 있는 식을 생각해보면 $123+123+123$ 같이 왼쪽 식이 3글자, 오른쪽 식이 3글자로 나오는 것을 생각할 수 있다. 또한, $123+1234567$처럼 6자리 이상의 수가 나오는 식은 $N$의 제한 때문에 생각할 필요가 없다.                  이를 종합하면, (수식)(연산자)(수)(연산자)(수식) 형태에서 왼쪽 부분 식의 길이가 1~3, 오른쪽 부분 식의 길이가 1~3인 경우에 대해 경우의 수를 구하면 된다. 왼쪽 식과 오른쪽 식의 값이 결정되면 가운데의 수는 자동으로 결정되며, 가운데 수의 길이가 $M -       l       -       r       - 2$인 경우만 경우의 수를 세서 더해주면 된다. 왼쪽 및 오른쪽 식이 가질 수 있는 값의 범위는 각각 절댓값 $10^       l       $, $10^       r       $ 내의 범위인 것을 고려하면 주어진 시간 내에 경우의 수를 구할 수 있다.           코드가 너무 길어서 여기 직접 적기는 힘들 것 같고, 여기에서 확인하자.   J. 부도덕한 그래프 (Hard)  문제 링크   두 가지 풀이가 있다. 하나는 sqrt decomposition이고, 하나는 bitset이다. 여기서는 둘 다 소개한다.   1. Sqrt Decomposition   처음 출제할 때 정해로 제안된 풀이다. ‘정점 $(x, y, z)$가 도덕적인 관계이다’라는 명제를 다음 세 조건을 모두 만족하는 것으로 정의하자.      간선 $(x, z)$가 존재한다.   간선 $(y, z)$가 존재한다.   간선 $(x, y)$ 또는 간선 $(y, x)$가 존재한다.   그래프에서 (도덕적인 관계의 수) + (부도덕한 관계의 수)는 쉽게 구할 수 있다. 각 정점에 $v$에 대해, indegree $\\deg_{in}(v)$를 구해서 $\\deg_{in}(v) \\cdot (\\deg_{in}(v) - 1) / 2$를 모두 더하면 된다.   이제 여기서 도덕적인 관계의 수를 제외하면 된다. Naive하게 하면 다음과 비슷한 방법으로 구할 수 있다.   for x, z in edges:     for y in adj_list_reverse[z]:         if y in adj_list[x]:             count += 1   adj_list_reverse는 주어진 그래프의 역방향 인접 리스트다. 이렇게 하면 최악의 경우 $O(M^2)$의 시간복잡도를 갖는다. 이를 sqrt decomposition 비슷한 아이디어를 이용해 $O(M \\sqrt{M})$으로 줄일 수 있다.   for x, z in edges:     if len(adj_list_reverse[z]) &lt;= len(adj_list[x]):         for y in adj_list_reverse[z]:             if y in adj_list[x]:                 count += 1      else:         for y in adj_list[x]:             if y in adj_list_reverse[z]:                 count += 1   adj_list_reverse는 주어진 그래프의 인접 리스트다. 이렇게 하면 시간복잡도는 아래와 같은 식이 된다   \\[\\sum_{(x, z) \\in E} \\min(\\deg_{out}(x), \\deg_{in}(z)) = O(M \\sqrt{M})\\]  증명은 다음과 같다. $\\sum_{x \\in V} \\deg_{out}(x) = M$이므로, $\\deg_{out}(x) &gt; \\sqrt(M)$인 정점은 많아야 $O(sqrt(M))$개이다. 그래프가 단순 그래프이므로, $\\min(\\deg_{out}(x), \\deg_{in}(z)) &gt; \\sqrt{M}$인 간선은 많아야 $O(M)$개이다. 나머지 간선에서는 $\\min(\\deg_{out}(x), \\deg_{in}(z)) \\leq \\sqrt{M}$이므로, 위 식이 성립한다.   저 증명은 jh05013님의 블로그 글에서 무방향 그래프를 방향 그래프로 바꾼 것 밖에 없다. 저게 왜 웰노운이야…   2. Bitset   본 대회에서 나온 유일한 풀이다. 1번 풀이와 (도덕적인 관계의 수) + (부도덕한 관계의 수)를 구하는 것까지는 동일하다. 그런데 이후 과정에서 bitset을 사용하면 엄청 빠른 $O(N^2)$ 풀이가 먹힌다.   우선, $N \\times N$ 크기의 인접 행렬을 vector&lt;bitset&lt;50000&gt;&gt;으로 저장해둔다. 이때 원본 그래프와 역방향 그래프 모두 저장해둔다. 이제 각 정점 $z$에 대해, 다음과 같은 과정을 거친다.   for (int z = 0; z &lt; n; z++) {     for (int x : adj_list_rev[z]) {         count += (adj_mat_rev[z] &amp; adj_mat[x]).count();     } }   K. 특별한 정점   문제 링크   기본적인 아이디어와 증명은 정말 어려운데, 구현은 정말 쉽다. 다만 구현에서 실수할 부분이 아예 없진 않다.   기본적인 아이디어는 다음과 같다.      두 개의 특별한 정점 $u$, $v$에 대해 $u$에서 $v$로 가는 단순 경로에 속하는 모든 특별한 정점들을 하나의 집합으로 보자. 정답은 그러한 집합의 수가 최소가 되도록 나눴을 때의 집합의 수 -1개가 된다. (특별한 정점이 존재하지 않을 경우 0)    아직 작성중입니다.     L. 수열 재활용   문제 링크   작성 준비중입니다.   M. 🍕😋🤮   문제 링크   작성 준비중입니다.   정리   작성 준비중입니다.  ","categories": ["Contest"],
        "tags": ["Contest","Editorial","KHSPC","KHSPC-2025"],
        "url": "/cs-blog/contest/KHSPC-%EB%92%B7%EB%B6%81-%ED%9B%84%EA%B8%B0-+-%EB%B9%84%EA%B3%B5%EC%8B%9D-%EC%97%90%EB%94%94%ED%86%A0%EB%A6%AC%EC%96%BC-(2)/",
        "teaser": null
      }]
