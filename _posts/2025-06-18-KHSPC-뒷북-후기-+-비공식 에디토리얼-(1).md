---
Title: 2025-06-18-KHSPC-뒷북-후기-+-비공식 에디토리얼
categories:
  - Algorithm
tags:
  - Algorithm-Normal
  - Geometry
toc: true
use_math: true
---

[대회 링크](https://www.acmicpc.net/contest/view/1504)

# 문제

## A. 태권도와 복싱을 합한 운동
[문제 링크](https://www.acmicpc.net/problem/33937)

그냥 시키는 걸 풀면 된다. 다만 문자열에 모음이 없거나 첫 모음 뒤 자음이 없는 경우에 답이 없다는 걸 조심하자. C++ 등 문자열을 다루기 귀찮은 언어에서 플래그를 이용해 자음/모음의 등장 여부를 따지는 경우라면 특히 더 조심하자.

```python
def get_first_syllable(a):
    for i in range(len(a) - 1):
        if a[i] in "aeiou" and not a[i + 1] in "aeiou":
            return a[:i + 1]
    return ""

def main():
    a = input()
    b = input()

    aa = get_first_syllable(a)
    bb = get_first_syllable(b)

    if aa == "" or bb == "":
        print("no such exercise")
    else:
        print(aa + bb)

if __name__ == "__main__":
    main()
```

## B. 간단한 동전 문제 (Easy)
[문제 링크](https://www.acmicpc.net/problem/33938)

간단한 case work + brtue force 문제다. 동전의 갯수 $N$에 따라 다음과 같이 풀면 된다.

1. $N = 0$

    $M = 0$이라면 정답은 $0$, 아니면 $-1$이다.

2. $N = 1$
   * $P_1 = 0$일 때

     $M$이 $0$이면 정답은 $0$, 아니면 $-1$이다.
  
   * $P_1 \neq 0$일 때

     $M$을 $P_1$으로 나눈 나머지가 $0$이고 $M / P_1 \geq 0$이면 $M / P_1$, 아니면 $-1이 정답이다.

3. $N = 2$
   
    1번째 동전을 내는 갯수와 2번째 동전을 내는 갯수를 각각 $x_1, x_2$라고 할 때, $x_1$과 $x_2$를 $0 \leq x_1, x_2 \leq 2000$ 정도의 범위에서 브루트포스를 돌리면 된다. $x_1 P_1 + x_2 P_2 = M$을 만족하는 $(x_1, x_2)$ 중 $x_1 + x_2$가 최소인 것을 찾으면 된다. 만약 그런 $(x_1, x_2)$가 없다면 $-1$을 출력한다.

    $x_1$ 하나에 대해서만 브루트포스를 돌리고 $x_2$는 $M - x_1 P_1$을 $P_2$로 나눈 후 나머지가 $0$, 몫이 양수인지를 확인하는 방법도 있긴 하다. 하지만 $P$가 $0$인 경우를 고려해야 하므로 이 방법은 조금 더 복잡하다.

분명히 두 번째로 쉬운 문제라고 냈는데, 본 대회에서 정답률이 5%대(...)가 나왔다. $N = 0$이거나 $P$ 중에 $0$이 있는 경우를 잘 생각하지 못해서 그런 것 같긴 한데... 그 와중에 상위권 참가자들은 이 문제의 Hard 버전을 먼저 풀기 위해 이걸 안 풀고 넘기고 있었는데, 그 문제도 굉장히 치명적인 함정이 있던 문제였다.

## C. 부도덕한 그래프 (Easy)
[문제 링크](https://www.acmicpc.net/problem/33939)

모든 가능한 $(x, y, z)$ 쌍에 대해 브루트포스를 돌리면 $O(N^3)$이라 시간 초과가 난다. 정점 대신 간선을 기준으로 생각하면 $O(M^2)$ 시간복잡도로 풀 수 있다.

모든 순서 없는 간선 쌍 $\{e_i, e_j\} = \{(u_1, v_1), (u_2, v_2)\}$ (단, $i < j$)에 대해 다음과 같은 조건을 만족하는지 확인한다.

1. $u_1 \neq u_2$
2. $v_1 = v_2$
3. $u_1$과 $u_2$ 사이에 간선이 없다

이 조건을 만족하는 간선 쌍의 개수를 세면 된다. 이때, 각 $u_1$과 $u_2$ 사이에 간선이 없다는 조건은 $O(N^2)$ 시간 및 메모리 복잡도로 인접 행렬을 전처리하면 $O(1)$로 확인할 수 있다. 따라서 전체 시간 복잡도는 $O(M^2 + N^2)$이 된다.

구현 자체는 꽤 간단한데, PS를 많이 안 해본 사람들은 저런 발상을 하는 게 쉽지 않을 것 같다.

```cpp
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
const ll MOD9 = 998244353;
const ll MOD1 = (ll)1e9 + 7;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    int n, m;
    cin >> n >> m;
    vector<vector<int>> adj_mat(n, vector<int>(n));
    vector<pii> edges(m);
    for (int i = 0; i < m; i++) {
        int s, e;
        cin >> s >> e;
        s--, e--;
        edges[i] = {s, e};
        adj_mat[s][e] = 1;
    }

    ll ans = 0;
    for (int i = 0; i < m; i++) {
        int u1 = edges[i].first, v1 = edges[i].second;
        for (int j = i + 1; j < m; j++) {
            int u2 = edges[j].first, v2 = edges[j].second;
            if (u1 == u2) {
                continue;
            }
            if (v1 != v2) {
                continue;
            }
            if (!adj_mat[u1][u2] && !adj_mat[u2][u1]) {
                ans++;
            }
        }
    }

    cout << ans << endl;

    return 0;
}
```

## D. 부분 수열 고르기
[문제 링크](https://www.acmicpc.net/problem/33940)

임의의 자연수 $L$ ($L \leq N$)에 대해, 주어진 등차수열에서 $L$개의 원소를 골라 합을 $M$으로 만들 수 있는지 $O(1)$만에 판단할 수 있다.

수열 $A$에서 제일 작은 원소 $L$개를 골랐을 때의 합은 초항 $a$ 공차 $d$인 등차수열의 첫 $L$개 원소의 합을 구하는 것과 같다. 즉, $M \leq L \cdot a + d \cdot \frac{L \cdot (L - 1)}{2}$이어야 한다.

반대로, 제일 큰 원소 $L$개를 골랐을 때의 합은 초항 $a + d \cdot (N - L)$ 공차 $d$인 등차수열의 첫 $L$개 원소의 합을 구하는 것과 같다. 즉, $M \geq L \cdot (a + d \cdot (N - L)) + d \cdot \frac{L \cdot (L - 1)}{2}$이어야 한다.

그리고 $M$을 $d$로 나눈 나머지에 대해서도 생각해야 한다. $A$에서 수를 어떻게 선택하든, 그 합은 $La + pd$ ($p$는 자연수) 꼴이 된다. 따라서 $M \equiv La \pmod{d}$이어야 한다.

정리하면,

1. $M \leq L \cdot a + d \cdot \frac{L \cdot (L - 1)}{2}$
2. $M \geq L \cdot (a + d \cdot (N - L)) + d \cdot \frac{L \cdot (L - 1)}{2}$
3. $M \equiv La \pmod{d}$

어떤 $L$이 이 세 조건을 만족한다면, **반드시** $L$개의 원소를 골라 합을 $M$으로 만들 수 있다. 브루트포스를 통해 가장 큰 $L$을 $O(N)$만에 찾을 수 있고, $L$을 찾았다면 합을 $M$으로 만드는 원소를 실제로 찾아야 한다.

먼저, 모든 원소를 최소값으로 선택하고 이 때의 부분 수열을 $A'$, $A'$의 합을 $S$라고 하자. 이때, $S = L \cdot a + d \cdot \frac{L \cdot (L - 1)}{2}$이고 $A'$은 오름차순으로 정렬되어 있다. $i = L$로 시작하고, $S < M$인 동안 다음을 반복하면 된다.

> $S - M \leq d \cdot (N - L)$이면, $A'$의 $i$번째 원소에 $S - M$을 더하고, $S$를 $M$으로 바꾼 후 루프를 종료한다.
>
> $A'$의 $i$번째 원소를 현재 쓰이지 않은 $A$의 가장 큰 원소 ($=A'_{i} + d \cdot (N - L)$)로 바꾼다.
>
> $S$를 $S + d \cdot (N - L)$로 바꾼다.
>
> $i$를 $i - 1$로 바꾼다.

위 과정은 $A'$의 $i$번째 원소와 현재 쓰이지 않은 $A$의 가장 큰 원소의 차가 $d \cdot (N - L)$이라는 관찰에서 나온 것이다. $L = 3$, $N = 7$인 경우를 예시로 들면, 맨 처음에 $A' = [A_1, A_2, A_3]$이다. 맨 뒤 원소인 $A_3$은 $A_7$로 바꿀 수 있으므로 두 수의 차이는 $d \cdot (7 - 3) = 4d$가 된다. 마찬가지로 $A_2$는 $A_7$이 이미 사용되었으므로 최대 $A_6$으로 바꿀 수 있고, 두 수의 차이는 마찬가지로 $d \cdot (6 - 2) = 4d$가 된다.

이 과정의 시간복잡도는 $O(N)$이다. 따라서 전체 시간복잡도는 $O(N) + O(N) = O(N)$이 된다.

기본적인 발상 자체는 꽤 쉽지만, 식 정리나 구현 과정이 꽤 복잡한 문제다. 바로 앞 문제랑 비교하면 그런 점이 특히 더 두드러지는 것 같다.

```cpp
#include <bits/stdc++.h>
 
using namespace std;
typedef long long ll;
typedef long double ld;
typedef pair<int, int> pii;
typedef pair<ll, ll> pll;
const ll MOD9 = 998244353;
const ll MOD1 = (ll)1e9 + 7;
 
int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
 
    ll n, a, d, m;
    cin >> n >> a >> d >> m;
 
    for (int l = n; l >= 1; l--) {
        // check if l is valid
        ll min_sum = a * l + d * l * (l - 1) / 2;
        ll max_sum = (a + d * (n - l)) * l + d * l * (l - 1) / 2;
        if (min_sum % d != m % d) {
            continue;
        }
        if (m < min_sum || m > max_sum) {
            continue;
        }

        // l is valid, construct the answer
        ll diff = (m - min_sum) / d;
 
        vector<ll> ans(l);
        for (int i = 0; i < l; i++) {
            ans[i] = a + d * i;
        }
 
        ll movable = n - l;
        for (int i = l - 1; i >= 0; i--) {
            if (diff == 0) {
                break;
            }
            else if (diff >= movable) {
                ans[i] += d * movable;
                diff -= movable;
            }
            else {
                ans[i] += d * diff;
                diff = 0;
            }
        }
 
        cout << l << "\n";
        for (int i = 0; i < l; i++) {
            cout << ans[i] << " ";
        }
        return 0;
    }
 
    cout << -1;
    return 0;
}
```

## E. 잔돈 싫어
[문제 링크](https://www.acmicpc.net/problem/33941)

흔한 2차원 DP 문제다. 편의상 문제에서 주어지는 모든 금액을 10으로 나누고 문제를 생각하자. 또한, $A$ 중 값이 (10으로 나눈 후) 50 이상 2000 미만인 원소만 포함한 $A'$를 생각하자.

$dp[i][j]$를 $A'$의 첫 $i$개 원소까지 봤을 때, $50$으로 나눈 나머지가 $j$인 것 중 환불받을 수 있는 최대 금액이라고 하자. 만약 $50$으로 나눈 나머지를 $j$로 만들도록 환불이 불가능하면 $-\infin$이라고 하자. 그러면 초기조건과 점화식을 다음과 같이 세울 수 있다.

$$
dp[0][i] = 
\begin{cases}
0 & \text{if } i = 0 \\
-\infty & \text{if } i \ne 0
\end{cases}
\\
(0 \leq i < 50)
$$

$$
dp[i][j] = \max\left \{
\begin{array}{l}
dp[i - 1][j], \\
dp[i - 1][(j - A'[i - 1]) \bmod 50] + A'[i]
\end{array}

\right.

\\

(1 \leq i < N', \ 0 \leq j < 50)
$$

$A'$의 길이를 $N'$이라 했을 때, 정답은 $dp[N'][0]$이다.

## F. MEX의 MEX
[문제 링크](https://www.acmicpc.net/problem/33942)

꽤 전형적인 이분 탐색 문제다. 